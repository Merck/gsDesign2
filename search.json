[{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Average hazard ratio and sample size under non-proportional hazards","text":"document demonstrates applications average hazard ratio concept design fixed designs without interim analysis. Throughout consider 2-arm trial experimental control group time--event endpoint. Testing differences treatment groups performed using stratified logrank test. setting, gsDesign2::AHR() routine provides average hazard ratio can used sample size using function gsDesign::nSurv(). approach assumes piecewise constant enrollment rates piecewise exponential failure rates option including multiple strata. approach allows flexibility approximate wide variety scenarios. evaluate approximations used via simulation using simtrial package; specifically provide simulation routine changes specified user easily incorporated. consider non-proportional hazards single stratum multiple strata different underlying proportional hazards assumptions. two things note regarding differences simtrial::simfix() gsDesign2::AHR(): simtrial::simfix() less flexible requires strata enrolled relative rates throughout trial whereas gsDesign2::AHR() allows, example, enrollment start stop different times different strata. document, use restrictive parameterization simtrial::simfix() can confirm asymptotic sample size approximation based gsDesign2::AHR() simulation. simtrial::simfix() provides flexibility test statistics used gsDesign2::AHR() documented pMaxCombo vignette demonstrating use Fleming-Harrington weighted logrank tests combinations tests.","code":""},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"document-organization","dir":"Articles","previous_headings":"Introduction","what":"Document organization","title":"Average hazard ratio and sample size under non-proportional hazards","text":"vignette organized follows: single stratum design assumes delayed treatment benefit. stratified example assumes different proportional hazards 3 strata. Decription design scenario. Deriving average hazard ratio. Deriving sample size based average hazard ratio. Computing plotting average hazard ratio function time. Simulation verify sample size approximation provides targeted power. simulation done data cutoff performed 5 different ways: Based targeted trial duration Based targeted minimum follow-duration Based targeted event count Based maximum targeted event count targeted trial duration Based maximum targeted event count targeted minimum follow-method based waiting achieve targeted event count targeted minimum follow-appears practical provide targeted power.","code":""},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"intial-setup","dir":"Articles","previous_headings":"Introduction","what":"Intial setup","title":"Average hazard ratio and sample size under non-proportional hazards","text":"begin setting two parameters used throughout simulations used verify accuracy power approximations; either customized simulation. First, set number simulations performed. can increase improve accuracy simulation estimates power. Simulations using simtrial::simfix() routine use blocked randomization. set change individual simulations. Based balanced randomization block set randomization ratio experimental control 1. load packages needed . gsDesign used implementation Schoenfeld (1981) approximation compute number events required power trial proportional hazards assumption. dplyr tibble work tabular data ‘data wrangling’ approach coding. simtrial enable simulations. survival enable Cox proportional hazards estimation (average) hazard ratio simulation compare approximation provided gsDesign2::AHR() routine computes expected average hazard ratio trial (Kalbfleisch Prentice (1981), Schemper, Wakounig, Heinze (2009)). Hidden underneath gsDesign2::eEvents_df() routine provides expected event counts period stratum hazard ratio differs. basic calculation used gsDesign2::AHR() routine.","code":"nsim <- 2000 block <- rep(c(\"Control\", \"Experimental\"), 2) ratio <- 1 library(gsDesign2) library(gsDesign) library(ggplot2) library(dplyr) library(tibble) library(simtrial) library(survival) library(knitr)"},{"path":[]},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"design-scenario","dir":"Articles","previous_headings":"Single stratum non-proportional hazards example","what":"Design scenario","title":"Average hazard ratio and sample size under non-proportional hazards","text":"set first scenario design parameters. Enrollment ramps course first 4 months follow-steady state enrollment thereafter. adjusted proportionately power trial later. control group piecewise exponential distribution median 9 first 3 months 18 thereafter. hazard ratio experimental group versus control 1 first 3 months followed 0.55 thereafter. Since single stratum, set strata default:","code":"enrollRates <- tibble::tibble(   Stratum = \"All\", # Note: this is done differently for multiple strata; see below!   duration = c(2, 2, 10),   rate = c(3, 6, 9) ) failRates <- tibble::tibble(   Stratum = \"All\",   duration = c(3, 100),   failRate = log(2) / c(9, 18),   hr = c(1, .55),   dropoutRate = .001 ) totalDuration <- 30 strata <- tibble::tibble(Stratum = \"All\", p = 1)"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"computing-average-hazard-ratio","dir":"Articles","previous_headings":"Single stratum non-proportional hazards example","what":"Computing average hazard ratio","title":"Average hazard ratio and sample size under non-proportional hazards","text":"compute average hazard ratio using gsDesign2::AHR() (average hazard ratio) routine. modify enrollment rates proportionately sample size computed. result given enrollment rates adjusted next step. However, since adjusted proportionately relative enrollment timing changing, average hazard ratio change. Approximations statistical information null (info0) alternate (info) hypotheses provided . Recall parameterization terms \\(\\log(HR)\\), , thus information intended approximate 1 variance Cox regression coefficient treatment effect; checked simulation later. result can explained number events observed first 3 months treatment treatment group. Now can replicate geometric average hazard ratio (AHR) computed using AHR() routine . compute logarithm HR computed weighted average weighting expected number events hazard ratio. Exponentiating resulting weighted average gives geometric mean hazard ratio, label AHR.","code":"avehr <- gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = as.numeric(totalDuration) ) avehr %>% kable(digits = 3) xx <-   gsDesign2::AHR(     enrollRates = enrollRates,     failRates = failRates,     totalDuration = as.numeric(totalDuration),     simple = FALSE   ) xx %>% kable(digits = 3) xx %>%   summarize(AHR = exp(sum(Events * log(HR) / sum(Events)))) %>%   kable(digits = 3)"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"deriving-the-design","dir":"Articles","previous_headings":"Single stratum non-proportional hazards example","what":"Deriving the design","title":"Average hazard ratio and sample size under non-proportional hazards","text":"average hazard ratio, use call gsDesign::nEvents() uses Schoenfeld (1981) approximation derive targeted number events. need average hazard ratio , randomization ratio (experimental/control), Type error Type II error (1 - power). also compute proportionately increase enrollment rates achieve targeted number events; round number events required next higher integer. also compute sample size, rounding nearest even integer.","code":"targetEvents <-   gsDesign::nEvents(     hr = avehr$AHR, # average hazard ratio computed above     ratio = 1, # randomization ratio     alpha = .025, # 1-sided Type I error     beta = .1 # Type II error (1-power)   ) targetEvents <- ceiling(targetEvents) targetEvents #> [1] 309 # Update enrollRates to obtain targeted events enrollRates$rate <- ceiling(targetEvents) / avehr$Events * enrollRates$rate avehr <- gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = as.numeric(totalDuration) ) avehr %>% kable(digits = 3) # round up sample size in both treatment groups sampleSize <- ceiling(sum(enrollRates$rate * enrollRates$duration) / 2) * 2 sampleSize #> [1] 576"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"average-hazard-ratio-and-expected-event-accumulation-over-time","dir":"Articles","previous_headings":"Single stratum non-proportional hazards example","what":"Average hazard ratio and expected event accumulation over time","title":"Average hazard ratio and sample size under non-proportional hazards","text":"examine average hazard ratio function trial duration modified enrollment required power trial. also plot expected event accrual time; although graphs go 40 months, recall targeted trial duration 30 months. key design consideration selecting trial duration based things like degree AHR improvement time versus urgency completing trial quickly possible, noting required sample size decrease longer follow-.","code":"avehrtbl <- gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = 1:(totalDuration + 10) ) ggplot(avehrtbl, aes(x = Time, y = AHR)) +   geom_line() +   ylab(\"Average HR\") +   ggtitle(\"Average HR as a function of study duration\") +   scale_x_continuous(breaks = seq(0, 48, 6)) ggplot(avehrtbl, aes(x = Time, y = Events)) +   geom_line() +   ylab(\"Expected events\") +   ggtitle(\"Expected event accumulation as a function of study duration\") +   scale_x_continuous(breaks = seq(0, 48, 6))"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"simulation-to-verify-power","dir":"Articles","previous_headings":"Single stratum non-proportional hazards example","what":"Simulation to verify power","title":"Average hazard ratio and sample size under non-proportional hazards","text":"use function simtrial::simfix() simplify setting executing simulation evaluate sample size derivation . Arguments simtrial::simfix() slightly different set-used gsDesign2::AHR() function used . Thus, reformatting input parameters involved. One difference gsDesign2::AHR() parameterization simtrial::simfix() block provided specify fixed block randomization opposed ratio gsDesign2::AHR(). following summarizes outcomes data cutoff chosen. Regardless cutoff chosen, see power approximates targeted 90% quite well. statistical information computed simulation computed one simulation variance Cox regression coefficient treatment (.e., log hazard ratio). column HR exponentiated mean Cox regression coefficients (geometric mean HR). see HR estimate matches simulations quite well. column info estimated statistical information alternate hypothesis, info0 estimate null hypothesis. value info0 1/4 expected events calculated . case, information approximation alternate hypothesis appears slightly small, meaning asymptotic approximation used overpower trial. Nonetheless, approximation power appear quite good noted .","code":"# do simulations # Cut at targeted study duration results1 <- simtrial::simfix(   nsim = nsim,   block = block,   sampleSize = sampleSize,   strata = strata,   enrollRates = enrollRates,   failRates = failRates,   totalDuration = totalDuration,   targetEvents = ceiling(targetEvents),   timingType = 1:5 ) # save(results1, file = './fixutes/results1.Rdata') # Save the data load(\"./fixtures/results1.Rdata\") # loading the data previously saved  results1$Positive <- results1$Z <= qnorm(.025) results1 %>%   group_by(cut) %>%   summarise(     Simulations = n(), Power = mean(Positive), sdDur = sd(Duration), Duration = mean(Duration),     sdEvents = sd(Events), Events = mean(Events),     HR = exp(mean(lnhr)), sdlnhr = sd(lnhr), info = 1 / sdlnhr^2   ) %>%   kable(digits = 3) avehr %>% kable(digits = 3)"},{"path":[]},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"design-scenario-1","dir":"Articles","previous_headings":"Different proportional hazards by strata","what":"Design scenario","title":"Average hazard ratio and sample size under non-proportional hazards","text":"set design scenario parameter. limited simultaneous enrollment strata since simtrial::simfix() routine uses simtrial::simPWSurv() limited scenario. specify three strata: High risk: 1/3 population median time--event 6 months treatment effect hazard ratio 1.2. Moderate risk: 1/2 population median time--event 9 months hazard ratio 0.2. Low risk: 1/6 population essentially cured arms (median 100, HR = 1).","code":"strata <- tibble::tibble(Stratum = c(\"High\", \"Moderate\", \"Low\"), p = c(1 / 3, 1 / 2, 1 / 6)) enrollRates <- tibble::tibble(   Stratum = c(array(\"High\", 4), array(\"Moderate\", 4), array(\"Low\", 4)),   duration = rep(c(2, 2, 2, 18), 3),   rate = c((1:4) / 3, (1:4) / 2, (1:4) / 6) ) failRates <- tibble::tibble(   Stratum = c(\"High\", \"Moderate\", \"Low\"),   duration = 100,   failRate = log(2) / c(6, 9, 100),   hr = c(1.2, 1 / 3, 1),   dropoutRate = .001 ) totalDuration <- 36"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"computing-average-hazard-ratio-1","dir":"Articles","previous_headings":"Different proportional hazards by strata","what":"Computing average hazard ratio","title":"Average hazard ratio and sample size under non-proportional hazards","text":"Now transform enrollment rates account stratified population. examine expected events stratum. Getting average log(HR) weighted Events exponentiating, get overall AHR just derived.","code":"ahr2 <- gsDesign2::AHR(enrollRates, failRates, totalDuration) ahr2 %>% kable(digits = 3) xx <- gsDesign2::AHR(enrollRates, failRates, totalDuration, simple = FALSE) xx %>% kable(digits = 3) xx %>%   ungroup() %>%   summarise(lnhr = sum(Events * log(HR)) / sum(Events), AHR = exp(lnhr)) %>%   kable(digits = 3)"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"deriving-the-design-1","dir":"Articles","previous_headings":"Different proportional hazards by strata","what":"Deriving the design","title":"Average hazard ratio and sample size under non-proportional hazards","text":"derive sample size . plan sample size based average hazard ratio overall population use across strata. First, derive targeted events: Next, adapt enrollment rates proportionately trial powered targeted failure rates follow-duration. targeted sample size, rounding even integer, :","code":"targetEvents <-   gsDesign::nEvents(     hr = ahr2$AHR,     ratio = 1,     alpha = .025,     beta = .1   ) targetEvents <- ceiling(targetEvents) targetEvents #> [1] 216 enrollRates <- enrollRates %>% mutate(rate = targetEvents / ahr2$Events * rate) gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = totalDuration ) %>%   kable(digits = 3) sampleSize <- ceiling(sum(enrollRates$rate * enrollRates$duration) / 2) * 2 sampleSize #> [1] 340"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"average-hr-and-expected-event-accumulation-over-time","dir":"Articles","previous_headings":"Different proportional hazards by strata","what":"Average HR and expected event accumulation over time","title":"Average hazard ratio and sample size under non-proportional hazards","text":"Plotting average hazard ratio function study duration, see improves considerably course study. also plot expected event accumulation. , plot 10 months planned study duration 36 months allow evaluation event accumulation versus treatment effect different trial durations.","code":"avehrtbl <- gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = 1:(totalDuration + 10) ) ggplot(avehrtbl, aes(x = Time, y = AHR)) +   geom_line() +   ylab(\"Average HR\") +   ggtitle(\"Average HR as a function of study duration\") +   scale_x_continuous(breaks = seq(0, 48, 6)) ggplot(avehrtbl, aes(x = Time, y = Events)) +   geom_line() +   ylab(\"Expected events\") +   ggtitle(\"Expected event accumulation as a function of study duration\") +   scale_x_continuous(breaks = seq(0, 48, 6))"},{"path":"https://merck.github.io/gsDesign2/articles/AHRVignette.html","id":"simulation-to-verify-power-1","dir":"Articles","previous_headings":"Different proportional hazards by strata","what":"Simulation to verify power","title":"Average hazard ratio and sample size under non-proportional hazards","text":"change enrollment rates stratum produced gsDesign::nSurv() overall enrollment rates needed simtrial::simfix(). Now simulate summarize results. , see expected statistical information simulation greater expected Schoenfeld approximation expected events divided 4. Finally, compare simulation results asymptotic approximation . achieved power simulation just targeted 90%; noting simulation standard error 0.006, asymptotic approximation quite good. Using final cutoff requires targeted events minimum follow-seems reasonable convention preserved targeted design power.","code":"er <- enrollRates %>%   group_by(Stratum) %>%   mutate(period = 1:n()) %>%   group_by(period) %>%   summarise(rate = sum(rate), duration = last(duration)) er %>% kable(digits = 3) results2 <-   simtrial::simfix(     nsim = nsim,     block = block,     sampleSize = sampleSize,     strata = strata,     enrollRates = er,     failRates = failRates,     totalDuration = as.numeric(totalDuration),     targetEvents = as.numeric(targetEvents),     timingType = 1:5   ) # save(results2, file = './fixtures/results2.Rdata') # Save data load(\"./fixtures/results2.Rdata\")  results2$Positive <- (pnorm(results2$Z) <= .025) results2 %>%   group_by(cut) %>%   summarize(     Simulations = n(), Power = mean(Positive), sdDur = sd(Duration), Duration = mean(Duration),     sdEvents = sd(Events), Events = mean(Events),     HR = exp(mean(lnhr)), sdlnhr = sd(lnhr), info = 1 / sdlnhr^2   ) %>%   kable(digits = 3) gsDesign2::AHR(   enrollRates = enrollRates,   failRates = failRates,   totalDuration = totalDuration ) %>% kable(digits = 3)"},{"path":[]},{"path":"https://merck.github.io/gsDesign2/articles/ArbitraryDistribution.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Approximating an Arbitrary Survival Distribution","text":"demonstrate approximate arbitrary continuous survival distibutions piecewise exponential approximations. enables sample size computations arbitrary survival models using software designed piecewise exponential distribution. Three functions particular demonstrated: s2pwe() translates arbitrary survival distribution piecewise exponential. ppwe() computes cumulative survival distribution upper tail distribution form generated s2pwe(). pPM() provides cumulative survival distribution Poisson mixture distribution.","code":""},{"path":"https://merck.github.io/gsDesign2/articles/ArbitraryDistribution.html","id":"lognormal-approximation","dir":"Articles","previous_headings":"","what":"Lognormal approximation","title":"Approximating an Arbitrary Survival Distribution","text":"demonstrate s2pwe() approximating lognormal distribution piecewise exponential failure rates. Note resulting lnormRates used, final piecewise exponential duration extended. , arbitrarily approximated 6 piecewise exponential rates duration 1 unit time (say, month) followed final rate extends infinity. compare resulting approximation actual lognormal survival using ppwe() compute survival probabilities \\(P\\{T>t\\}\\). better approximation, use larger number points. plot log scale y-axis since piecewise exponential survival ppwe() piecewise linear scale. note beginning rate period approximation actual survival distribution approximation match exactly indicated circles graph.  considered lognormal distribution due flexibility allows hazard rates time; see, example, Wikipedia.","code":"library(gsDesign2) lnormRates <- gsDesign2::s2pwe(   times = c(1:6, 9),   survival = plnorm(c(1:6, 9), meanlog = 0, sdlog = 2, lower.tail = FALSE) ) lnormRates ## # A tibble: 7 × 2 ##   duration  rate ##      <dbl> <dbl> ## 1        1 0.693 ## 2        1 0.316 ## 3        1 0.224 ## 4        1 0.177 ## 5        1 0.148 ## 6        1 0.128 ## 7        3 0.103 # Use a large number of points to plot lognormal survival times <- seq(0, 12, .025) plot(times, plnorm(times, meanlog = 0, sdlog = 2, lower.tail = FALSE),   log = \"y\", type = \"l\",   main = \"Lognormal Distribution vs. Piecewise Approximation\", yaxt = \"n\",   ylab = \"log(Survival)\", col = 1 )  # Now plot the pieceise approximation using the 7-point approximation from above lines(times, gsDesign2::ppwe(x = times, failRates = lnormRates), col = 2)  # Finally, add point markers at the points used in the approximation points(x = c(0:6), plnorm(c(0:6), meanlog = 0, sdlog = 2, lower.tail = FALSE), col = 1) text(x = c(5, 5), y = c(.5, .4), labels = c(\"Log-normal\", \"Piecewise Approximation (7 pts)\"), col = 1:2, pos = 4)"},{"path":"https://merck.github.io/gsDesign2/articles/ArbitraryDistribution.html","id":"poisson-mixture-model","dir":"Articles","previous_headings":"","what":"Poisson mixture model","title":"Approximating an Arbitrary Survival Distribution","text":"consider Poisson mixture model incorporate cure model sample size planning. form survival function \\[S(t)=\\exp(-\\theta F_0(t))\\] \\(t\\ge 0\\) \\(F_0(t)\\) continuous cumulative distribution function non-negative random variable \\(F_0(0)=0\\) \\(F_0(t)\\uparrow 1\\) \\(t\\uparrow \\infty\\). note \\(t\\uparrow \\infty\\), \\(S(t)\\downarrow \\exp(-\\theta)=c\\) refer \\(c\\) cure rate. function pPM() assumes \\(F_0(t)=1-\\exp(-\\lambda t)\\) exponential cumulative distribution function resulting survival distribution \\(t\\ge 0\\): \\[S(t; \\theta, \\lambda) = \\exp(-\\theta(1-\\exp(-\\lambda t))).\\] Note set default lower.tail=FALSE survival function computation default: plot \\(\\lambda = \\log(2) / 10\\) make \\(F_0(t)\\) exponential distribution median 10. set \\(\\theta = -\\log(.4)\\) obtain cure rate 0.4. overlay piecewise exponential approximation.  note two different \\(\\theta\\) values provide proportional hazards model ratio cumulative hazard function \\(H(t; \\theta, \\lambda) = \\theta\\exp(-\\lambda t)\\) constant: \\[\\frac{\\log(S(t; \\theta_1, \\lambda))}{\\log(S(t; \\theta_2, \\lambda))} = \\theta_1/\\theta_2.\\] given \\(\\theta\\) value can compute \\(\\lambda\\) provide survival rate \\(c_1 > \\exp(-\\theta)\\) arbitrary time \\(t_1>0\\) setting: \\[\\lambda = -\\log\\left(\\frac{\\theta - \\log(c_1)}{\\theta}\\right)/t_1.\\] compute \\(\\theta\\) \\(\\lambda\\) values cure rate 0.4 survival rate 0.6 30 months: confirm survival time 30:","code":"pPM <- function(x, theta, lambda, lower.tail = FALSE) {   exp(-theta * (1 - exp(-lambda * x))) } lambda <- log(2) / 10 theta <- -log(.4) times <- 0:40 plot(times, pPM(times, theta, lambda), type = \"l\", ylab = \"Survival\", xlab = \"Time\", log = \"y\") # Now compute piecewise expoential approximation x <- seq(8, 40, 8) pmRates <- gsDesign2::s2pwe(   times = x,   survival = pPM(x, theta = theta, lambda = lambda) )  # Now plot the pieceise approximation using the 7-point approximation from above lines(c(0, x), gsDesign2::ppwe(x = c(0, x), failRates = pmRates), col = 2) points(c(0, x), pPM(c(0, x), theta, lambda)) theta <- -log(0.4) lambda <- -log((theta + log(.6)) / theta) / 30 pPM(30, theta, lambda) ## [1] 0.6"},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Computing expected events by interval at risk","text":"document derives algorithm computing expected events observed model piecewise constant enrollment, failure dropout rates similar Lachin Foulkes (1986). Specifically, design enable computation average hazard ratio use elsewhere approximate sample size fixed group sequential designs non-proportional hazards assumption (Kalbfleisch Prentice (1981), Schemper, Wakounig, Heinze (2009)). expected events calculation outlined implemented function eEvents_df().","code":""},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"general-formulation-and-notation","dir":"Articles","previous_headings":"","what":"General formulation and notation","title":"Computing expected events by interval at risk","text":"notation, study time scale denoted \\(\\omega\\) study start first opening enrollment \\(\\omega=0\\). use variable \\(t\\) indicate patient time \\(t=0\\) representing time patient enrolled. assume patient time enrollment event independent identically distributed subjects enrolled. also assume patient time censoring independent identically distributed subjects enrolled. individual, let \\(X>0\\) denote patient time event \\(Y>0\\) denote patient time loss--follow-. also let \\(U\\) denote (independent) study time entry patient. assume triplet \\(X\\), \\(Y\\), \\(U\\) independent. consider single treatment group stratum assume subjects enroll according Poisson process entry rate \\(g(\\omega)\\geq 0\\) \\(0\\le \\omega\\). expected number subjects enrolled study time \\(\\omega\\) simply \\[\\begin{equation} G(\\omega)=\\int_0^\\omega g(u)du. \\end{equation}\\] Analysis time--event data done using time enrollment patient event, drops , censored prior event time data cutoff; consider data cutoff fixed time \\(\\Omega\\). key counts consider : \\(\\bar{N}(t)\\) : number patients events study least duration \\(0<t \\le \\Omega\\) time data cutoff study time \\(\\Omega\\). \\(\\bar{n}(t_1,t_2)\\equiv E\\{\\bar{N}(t_2)-\\bar{N}(t_1)\\}\\) : number patients events interval \\((t_1,t_2]\\), \\(0\\le t_1< t_2\\le \\Omega\\). focus expected value \\(\\bar{n}(t_1,t_2)\\) due usefulness computing average hazard ratio piecewise model outlined . patient count \\(\\bar{n}(t_1,t_2)\\) must enrolled prior time \\(\\Omega - t_1\\). Also, patient enrolled time \\(0<u<\\Omega\\) maximum time observed occurrence event \\(\\Omega - u\\). Thus, \\[\\begin{align} E\\{\\bar{n}(t_1,t_2)\\}&=\\int_0^{\\Omega-{t_1}} g(u)  P\\{t_1<X\\leq \\min(t_2,\\Omega-u), X\\leq Y\\} du\\nonumber\\\\ &=\\int_0^{\\Omega-t_2} g(u) P\\{t_1<X\\leq t_2, X\\leq Y\\} du+ \\int_{\\Omega-t_2}^{\\Omega-t_1} g(u) P\\{t_1< X\\leq \\Omega-u, X\\leq Y\\} du\\nonumber\\\\ &=G(\\Omega-t_2)P\\{t_1<X\\leq t_2, X\\leq Y\\}+  \\int_{\\Omega-t_2}^{\\Omega-t_1} g(u) P\\{t_1< X\\leq \\Omega-u, X\\leq Y\\} du.\\nonumber \\end{align}\\]","code":""},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"the-piecewise-model","dir":"Articles","previous_headings":"","what":"The piecewise model","title":"Computing expected events by interval at risk","text":"model follows: Piecewise constant enrollment rates allowed given enrollment rate often accelerates early trial. Piecewise exponential failure rates allowed allow changing outcome incidence time. Piecewise exponential censoring rates allow changing dropout rates time. fixed study duration. Lachin Foulkes (1986) provided general formulation calculating expected number events time scenario described . However, alter algorithm compute expected number events \\(E\\{\\bar n(t_1,t_2)\\}\\) follow-period constant failure rate; later enable computing average hazard ratio (Kalbfleisch Prentice (1981), Schemper, Wakounig, Heinze (2009)). define piecewise time--event dropout random variables patient time scale. assume \\(0=t_0<t_1<...<t_M=\\infty\\) \\(m=1,2,\\ldots,M\\). \\(m=1,2,\\ldots,M\\), assume \\(X_m>0\\), \\(Y_m>0\\) random variables independent study entry time \\(U\\). let \\(X_m\\) \\(Y_m\\) define \\(X\\) \\(Y\\), respectively, interval \\((t_{m-1},t_m]\\), \\(m=1,2,\\ldots,M\\), follows: \\[\\begin{align} X&=\\sum_{m=1}^M \\min(X_m,t_m-t_{m-1}) \\prod_{j=1}^{m-1}\\{X_j>t_j-t_{j-1}\\}\\label{eq:Xdef}\\\\ Y&=\\sum_{m=1}^M \\min(Y_m,t_m-t_{m-1})\\prod_{j=1}^{m-1}\\{Y_j>t_j-t_{j-1}\\}\\label{eq:Ydef}. \\end{align}\\] assume \\(X_m\\) \\(Y_m\\) independent exponentially distributed failure rates \\(\\lambda_m\\) \\(\\eta_m\\), respectively, \\(m=1,2,\\ldots,M\\). now assume subjects enroll constant rate \\(J\\) intervals defined \\(0=\\omega_0<\\omega_1<\\ldots<\\omega_J<\\infty\\). denote enrollment rates \\[\\begin{equation}g(\\omega)=\\gamma_j\\geq 0\\label{eq:gj}\\end{equation}\\] \\(\\omega\\) interval \\((\\omega_{j-1},\\omega_j]\\), \\(j=0,1,2,\\ldots,J\\). assume \\(\\gamma_1>0\\), \\(j>1\\) assume \\(\\gamma_j\\ge 0\\). Letting \\(G_0=0\\) recursively define \\(j=1,\\ldots,J\\) \\[\\begin{equation}G_j=G(\\omega_j)=G_{j-1}+\\gamma_j(\\omega_j-\\omega_{j-1})\\label{eq:Gj}\\end{equation}\\] thus \\(\\omega\\[\\omega_{j-1},\\omega_j]\\) expected enrollment study time \\(\\omega\\) \\[\\begin{equation}G(\\omega)=G_{j-1}+\\gamma_j(\\omega-\\omega_{j-1}).\\label{eq:ENpw}\\end{equation}\\]","code":""},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"an-example-under-the-piecewise-model","dir":"Articles","previous_headings":"The piecewise model","what":"An example under the piecewise model","title":"Computing expected events by interval at risk","text":"consider example piecewise model assuming \\(J=3\\), \\(\\omega_j=1,2,7\\) \\(\\gamma_j=3,2,0\\) \\(j=1,2,3\\). assume \\(M=2\\) \\(t_m=4,\\infty\\), failure rates \\(\\lambda_m=.03,.06\\), dropout rates \\(\\eta_m=0.001,.002\\). plot following plot enrollment rate axis right failure dropout rate axis left. plot \\(\\omega\\) reverse order related integration equation \\(E\\{\\bar{n}(t_1,t_2)\\}\\) . also plotted vertical dot-dashed line point either enrollment rate failure (dropout) rate changes.","code":""},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"organizing-calculations-under-the-piecewise-model","dir":"Articles","previous_headings":"The piecewise model","what":"Organizing calculations under the piecewise model","title":"Computing expected events by interval at risk","text":"now proceed define algorithms computing expected events observed interval model piecewise constant enrollment, failure rates, dropout rates. assume study duration \\(\\Omega=t_M\\). assume without loss generality sequence \\(t_m\\), \\(m=1,2,\\ldots, M\\) constant failure rate \\(\\lambda_m\\) dropout rate \\(\\eta_m\\) interval \\((t_{m-1},t_m]\\) well constant enrollment rate \\(\\gamma_m\\) interval \\((t_M-t_m,t_M-t_{m-1}]\\). Deriving intervals relatively straightforward exercise shown example . example, example , change points vertical lines drawn following scenario calculation purposes. define \\(m=1,\\ldots,M\\) intermediate probability calculations use calculating \\(\\bar n(t_{m-1},t_m)\\) follows: \\[\\begin{align} q_m&=P\\{\\min(X_m,Y_m)>t_m\\}=\\exp^{-(\\lambda_m+\\eta_m)(t_m-t_{m-1})} \\label{eq:qm}\\\\ Q_m&=P\\{\\min(X,Y)>t_m\\}=\\prod_{j=1}^m q_j\\label{eq:Qm}\\\\ d_m&=P\\{t_{m-1}<X\\le t_m,X\\le Y\\}\\\\ &=P\\{\\min(X,Y)>t_{m-1}\\}P\\{0<X_m\\le t_m-t_{m-1},X_m\\le Y_m\\}\\\\ &=Q_{m-1}(1-e^{-(\\lambda_m+\\eta_m)(t_m-t_{m-1})}) \\frac{\\lambda_m}{\\lambda_m+\\eta_m}\\\\ \\bar n_m&=E\\{\\bar n(t_{m-1},t_m)\\} \\end{align}\\] Note \\(\\lambda_m+\\eta_m=0\\), \\(d_m=0\\). , \\[\\begin{align} \\bar n_m&=G(t_M-t_m)P\\{t_{m-1}<X\\leq t_m, X\\leq Y\\}+  \\int_{t_M-t_m}^{t_M-t_{m-1}} g(u) P\\{t_{m-1}< X\\leq t_M-u, X\\leq Y\\} du\\\\ &=G_{M+1-m}d_m+P\\{\\min(X,Y)>t_{m-1}\\}  \\int_0^{t_m-t_{m-1}}g_{M+1-m}P\\{X_m\\le v, X_m\\le Y_m\\}dv\\\\ &=G_{M+1-m}d_m  + \\frac{Q_{m-1}g_{M+1-m}\\lambda_m}{\\lambda_m+\\eta_m}  \\int_0^{t_m-t_{m-1}}\\left(1-\\exp^{-(\\lambda_m+\\eta_m)v}\\right)dv\\\\ &=G_{M+1-m}d_m  + \\frac{Q_{m-1}g_{M+1-m}\\lambda_m}{\\lambda_m+\\eta_m} \\left(t_m-t_{m-1}-\\frac{1-\\exp^{-(\\lambda_m+\\eta_m)(t_m-t_{m-1})}}{\\lambda_m+\\eta_m}\\right)\\\\ &=G_{M+1-m}d_m  + \\frac{Q_{m-1}g_{M+1-m}\\lambda_m}{\\lambda_m+\\eta_m} \\left(t_m-t_{m-1}-\\frac{1-q_m}{\\lambda_m+\\eta_m}\\right) \\end{align}\\] now add \\(q_m\\), \\(Q_m\\), \\(d_m\\) calculations enable computation \\(\\bar n_m\\), expected events time interval.","code":"namesTem <- names(x) names(x) <- c(\"m\", \"tm\", \"lambda\", \"eta\", \"j\", \"omega\", \"gamma\") y <- x %>%   mutate(     tdel = tm - lag(tm, default = 0),     q = exp(-(lambda + eta) * tdel),     Q = lag(cumprod(q), default = 1),     d = Q * (1 - q) * lambda / (lambda + eta),     G = c(5, 5, 3, 0),     nbar = G * d + (lambda * Q * gamma) / (lambda + eta) * (tdel - (1 - q) / (lambda + eta))   ) yy <- y names(yy) <- c(   \"$m$\", \"$t_m$\", \"$\\\\lambda_m$\", \"$\\\\eta_m$\", \"$j$\",   \"$\\\\omega_j=t_M-t_{m-1}$\",   \"$\\\\gamma_j$\", \"$t_m-t_{m-1}$\", \"$q_m$\", \"$Q_{m-1}$\",   \"$d_m$\", \"$G_{j-1}$\", \"$\\\\bar{n}_m$\" ) yy <- yy %>% select(c(1:7, 12, 8:11, 13)) yy %>%   kable(digits = 4) %>%   kable_styling(c(\"striped\", \"bordered\")) %>%   add_header_above(c(     \"Failure and dropout rates\" = 4,     \"Enrollment\" = 4,     \"Events by time period\" = 5   ))"},{"path":"https://merck.github.io/gsDesign2/articles/eEventsTheory.html","id":"verifying-calculations","dir":"Articles","previous_headings":"The piecewise model","what":"Verifying calculations","title":"Computing expected events by interval at risk","text":"check total number events using gsDesign function eEvents(). First, sum \\(\\bar{n}_m\\) values sum(y$nbar) get 1.083773 compare : Next, examine periods defined failRates: Now group rows y intervals. Finally, approximate specific numbers using simulation. First, simulate large dataset confirm simulation targeted enrollment pattern. Now confirm expected events follow-interval given targeted enrollment.","code":"Events <- gsDesign::eEvents(   lambda = y$lambda,   eta = y$eta,   gamma = y$gamma[length(y$gamma):1],   S = y$tdel[1:(length(y$tdel) - 1)],   R = y$tdel[(length(y$tdel):1)],   T = max(y$tm) )$d Events #> [1] 1.083773 library(gsDesign2)  eEvents_df(   enrollRates = tibble(     duration = c(1, 1),     rate = c(3, 2)   ),   failRates = tibble(     duration = c(4, 3),     failRate = c(.03, .06),     dropoutRate = c(.001, .002)   ),   totalDuration = 7,   simple = FALSE ) #> # A tibble: 2 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0     0.03  0.564 #> 2     4     0.06  0.519 y %>%   mutate(t = c(0, 4, 4, 4)) %>%   group_by(t) %>%   summarise(     failRate = first(lambda),     Events = sum(nbar)   ) #> # A tibble: 2 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0     0.03  0.564 #> 2     4     0.06  0.519 nsim <- 1000000 xx <- simtrial::simPWSurv(   n = nsim,   block = (rep(\"xx\", 4)),   enrollRates = tibble(rate = c(3, 2) * nsim / 5, duration = c(1, 1)),   failRates = tibble(     Stratum = \"All\", period = 1:2, Treatment = \"xx\",     rate = c(.03, .06), duration = c(4, Inf)   ),   dropoutRates = tibble(     Stratum = \"All\", period = 1:2, Treatment = \"xx\",     rate = c(.001, .002), duration = c(4, Inf)   ) ) ecat <- 1 + (xx$enrollTime > 1) + (xx$enrollTime > 2) cat(\"Enrollment pattern: \", table(ecat) / nsim) #> Enrollment pattern:  0.599379 0.398344 0.002277 yy <- xx %>%   simtrial::cutData(7) %>%   filter(event == 1) %>%   mutate(tcat = 4 + (tte > 4) + (tte > 5) + (tte > 6)) cat(\"Event by interval: \", table(yy$tcat) / nsim * 5, \"\\n\") #> Event by interval:  0.56449 0.25609 0.193975 0.06953 cat(\"Total events: \", sum(yy$event) / nsim * 5) #> Total events:  1.084085"},{"path":[]},{"path":"https://merck.github.io/gsDesign2/articles/testing_AHR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulation for testing average hazard ratio and sample size under non-proportional hazards","text":"document demonstrates simple simulation unit testing average hazard ratio function (AHR()). details calculating average hazard ratio already available vignette(\"AHRVignette\"), purpose vignette show simulation can conducted order approximate average hazard ratio. results used unit test see whether simulation results good approximation actual results AHR(). simulation wrapped function gives users flexibility design assumptions. simulations based targeted event , scenarios, similar approach can taken.","code":""},{"path":"https://merck.github.io/gsDesign2/articles/testing_AHR.html","id":"intial-setup","dir":"Articles","previous_headings":"Introduction","what":"Intial setup","title":"Simulation for testing average hazard ratio and sample size under non-proportional hazards","text":"begin setting two parameters used throughout simulations used verify accuracy power approximations; either customized simulation. First, set number simulations performed. can increase improve accuracy simulation estimates power.","code":"nsim <- 2000 block <- rep(c(\"Experimental\", \"Control\"), 2) strata <- tibble::tibble(Stratum = \"All\", p = 1)"},{"path":"https://merck.github.io/gsDesign2/articles/testing_AHR.html","id":"design-scenario","dir":"Articles","previous_headings":"Introduction","what":"Design scenario","title":"Simulation for testing average hazard ratio and sample size under non-proportional hazards","text":"set design parameters. Enrollment ramps course first 4 months follow-steady state enrollment thereafter. adjusted proportionately power trial later. control group piecewise exponential distribution median 9 first 3 months 18 thereafter. hazard ratio experimental group versus control 0.9 first 3 months followed 0.6 thereafter. Fleming-Harrington weights can defined case users want run weighted logrank tests, defined rg follows. simulation, consider sample size events given N events bounds interim analysis provided bounds. simulation average hazard ratio \\(k = 3\\) interim analysis can conducted follows: combining simulation results can summarized respect analysis time ","code":"enrollRates <- tibble::tibble(   Stratum = \"All\",   duration = c(2, 2, 10),   rate = c(3, 6, 9) ) failRates <- tibble::tibble(   Stratum = \"All\",   duration = c(3, 100),   failRate = log(2) / c(9, 18),   hr = c(.9, .6),   dropoutRate = rep(.001, 2) ) rg <- tibble(rho = 0, gamma = 0) N <- enrollRates %>% summarise(N = sum(rate * duration)) events <- c(20.4, 48.9, 66.1) bounds <- tibble::tibble(   k = 1:3,   upper = c(2.962588, 2.359018, 2.014084),   lower = c(qnorm(.05), qnorm(.1), -Inf) ) K <- length(events) fr <- simtrial::simfix2simPWSurv(failRates = failRates) simresult <- NULL for (i in 1:nsim) {   sim <- simtrial::simPWSurv(     n = as.numeric(N),     enrollRates = enrollRates,     failRates = fr$failRates,     dropoutRates = fr$dropoutRates,     strata = strata,     block = block   )   for (e in 1:K) {     dt <- simtrial::getCutDateForCount(x = sim, count = events[e])     ds <- sim %>% simtrial::cutData(dt)     res.cox <- coxph(Surv(time = tte, event = event) ~ Treatment + strata(Stratum), data = ds)     Cox.coef <- res.cox$coefficients     Z <- sim %>%       cutDataAtCount(events[e]) %>% # cut simulation for analysis at targeted events       tensurv(txval = \"Experimental\") %>%       tenFH(rg = rg)     simresult <- rbind(       simresult,       tibble(         sim = i,         k = e,         Events = events[e],         Z = -Z$Z, # Change sign for Z         Time = dt,         Cox.coef = Cox.coef       )     )   } }  simresult <- tibble(simresult, N) %>% mutate(N = as.integer(N)) simresult simresult %>%   full_join(bounds, by = \"k\") %>%   tidyr::gather(c(\"upper\", \"lower\"), key = \"Bounds\", value = \"value\") %>%   group_by(k, Bounds) %>%   summarize(     n = n(),     Time = mean(Time),     AHR = exp(mean(Cox.coef)),     z = unique(value),     Events = unique(Events)   ) %>%   mutate_if(is.numeric, round, digits = 4) %>%   arrange(desc(Bounds)) %>%   select(k, Bounds, Time, Events, AHR, z)"},{"path":"https://merck.github.io/gsDesign2/articles/testing_AHR.html","id":"putting-them-all-into-a-function","dir":"Articles","previous_headings":"","what":"Putting them all into a function","title":"Simulation for testing average hazard ratio and sample size under non-proportional hazards","text":"Finally, whole simulation approach wrapped function sim_gsd users can modify design assumptions based desired design. small simulation size 10 show results sim_gsd","code":"sim_gsd <- function(nsim = 1000,                     block = rep(c(\"Experimental\", \"Control\"), 2),                     strata = tibble::tibble(Stratum = \"All\", p = 1),                     enrollRates = tibble::tibble(                       Stratum = \"All\",                       duration = c(2, 2, 10),                       rate = c(3, 6, 9)                     ),                     failRates = tibble::tibble(                       Stratum = \"All\",                       duration = c(3, 100),                       failRate = log(2) / c(9, 18),                       hr = c(.9, .6),                       dropoutRate = rep(.001, 2)                     ),                     rg = tibble(rho = 0, gamma = 0),                     N = NULL,                     # events = c(158.954, 200.636, 252.077),                     events = c(20.4, 48.9, 66.1),                     bounds = tibble::tibble(                       k = 1:3,                       upper = c(2.962588, 2.359018, 2.014084),                       lower = c(qnorm(.05), qnorm(.1), -Inf)                     )) {   N <- ifelse(is.null(N), enrollRates %>% summarise(N = sum(rate * duration)), N)   K <- length(events)   fr <- simtrial::simfix2simPWSurv(failRates = failRates)   simresult <- NULL   for (i in 1:nsim) {     sim <- simtrial::simPWSurv(       n = as.numeric(N),       enrollRates = enrollRates,       failRates = fr$failRates,       dropoutRates = fr$dropoutRates,       strata = strata,       block = block     )     for (e in 1:K) {       dt <- simtrial::getCutDateForCount(x = sim, count = events[e])       ds <- sim %>% simtrial::cutData(dt)       res.cox <- coxph(Surv(time = tte, event = event) ~ Treatment + strata(Stratum), data = ds)       Cox.coef <- res.cox$coefficients       Z <- sim %>%         cutDataAtCount(events[e]) %>% # cut simulation for analysis at targeted events         tensurv(txval = \"Experimental\") %>%         tenFH(rg = rg)       simresult <- rbind(         simresult,         tibble(           sim = i,           k = e,           Events = events[e],           Z = -Z$Z, # Change sign for Z           Time = dt,           Cox.coef = Cox.coef         )       )     }   }    simresult <- tibble(simresult, N) %>% mutate(N = as.integer(N))   res <- simresult %>%     full_join(bounds, by = \"k\") %>%     tidyr::gather(c(\"upper\", \"lower\"), key = \"Bounds\", value = \"value\") %>%     group_by(k, Bounds) %>%     summarize(       n = n(),       Time = mean(Time),       AHR = exp(mean(Cox.coef)),       z = unique(value),       Events = unique(Events)     ) %>%     mutate_if(is.numeric, round, digits = 4) %>%     arrange(desc(Bounds)) %>%     select(k, Bounds, Time, Events, AHR, z)   res <- tibble::tibble(     Analysis = res$k,     Bound = res$Bounds,     Z = res$z,     Time = res$Time,     AHR = res$AHR,     Events = res$Events   )    res <- tibble(res, N) %>% mutate(N = as.integer(N))   return(res) } sim_gsd(nsim = 100)"},{"path":"https://merck.github.io/gsDesign2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author. Yilong Zhang. Author, maintainer. Amin Shirazi. Contributor. Ruixue Wang. Contributor. Yi Cui. Contributor. Ping Yang. Contributor. Xin Tong Li. Contributor. Yalin Zhu. Contributor. Nan Xiao. Contributor. Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder.","code":""},{"path":"https://merck.github.io/gsDesign2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhang Y (2022). gsDesign2: Group Sequential Design Non-Proportional Hazards. https://merck.github.io/gsDesign2/, https://github.com/Merck/gsDesign2.","code":"@Manual{,   title = {gsDesign2: Group Sequential Design Under Non-Proportional Hazards},   author = {Keaven Anderson and Yilong Zhang},   year = {2022},   note = {https://merck.github.io/gsDesign2/, https://github.com/Merck/gsDesign2}, }"},{"path":[]},{"path":"https://merck.github.io/gsDesign2/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Group Sequential Design Under Non-Proportional Hazards","text":"gsDesign2 package supports recent innovations group sequential clinical trial design including non-proportional hazards graphical multiplicity control group sequential design. Computations based piecewise constant enrollment piecewise exponential failure rates. Stratified populations supported. Power sample size calculations based using testing based logrank test.","code":""},{"path":"https://merck.github.io/gsDesign2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Group Sequential Design Under Non-Proportional Hazards","text":"can install GitHub:","code":"remotes::install_github(\"Merck/gsDesign2\")"},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":null,"dir":"Reference","previous_headings":"","what":"Average hazard ratio under non-proportional hazards (test version) — AHR","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"AHR() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"AHR(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   totalDuration = 30,   ratio = 1,   simple = TRUE )"},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. totalDuration Total follow-start enrollment data cutoff; can single value vector positive numbers. ratio ratio experimental control randomization. simple logical; TRUE (default), value input totalDuration overall event count, statistical information average hazard ratio given; FALSE, hazard ratio, expected events statistical information produced stratum underlying hazard ratio.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"tibble Time (totalDuration), AHR (average hazard ratio), Events (expected number events), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input; simple=FALSE, Stratum t (beginning constant HR period) also returned HR returned instead AHR","code":""},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"contents section shown PDF user manual .","code":""},{"path":"https://merck.github.io/gsDesign2/reference/AHR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"# Example: default AHR() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    30 0.695   58.5  14.3  14.6 # Example; default with multiple analysis times (varying totalDuration) AHR(totalDuration=c(15,30)) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.786   30.3  7.44  7.57 #> 2    30 0.695   58.5 14.3  14.6  # Stratified population enrollRates <- tibble::tibble(Stratum=c(rep(\"Low\",2),rep(\"High\",3)),                               duration=c(2,10,4,4,8),                               rate=c(5,10,0,3,6) ) failRates <- tibble::tibble(Stratum=c(rep(\"Low\",2),rep(\"High\",2)),                             duration=1,                             failRate=c(.1,.2,.3,.4),                             hr=c(.9,.75,.8,.6),                             dropoutRate=.001 ) AHR(enrollRates=enrollRates,     failRates=failRates,     totalDuration=c(15,30)    ) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.733   113.  28.1  28.3 #> 2    30 0.718   166.  41.3  41.5 # Same example, give results by strata and time period AHR(enrollRates=enrollRates,     failRates=failRates,     totalDuration=c(15,30),     simple=FALSE ) #> # A tibble: 8 × 7 #> # Groups:   Time, Stratum [4] #>    Time Stratum     t    HR Events  info info0 #>   <dbl> <chr>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 High        0  0.8   12.1   2.99  3.02 #> 2    15 High        1  0.6   23.1   5.72  5.78 #> 3    15 Low         0  0.9    9.96  2.48  2.49 #> 4    15 Low         1  0.75  68.1  16.9  17.0  #> 5    30 High        0  0.8   14.2   3.51  3.54 #> 6    30 High        1  0.6   45.2  11.2  11.3  #> 7    30 Low         0  0.9    9.96  2.48  2.49 #> 8    30 Low         1  0.75  96.8  24.1  24.2"},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise constant expected accrual — eAccrual","title":"Piecewise constant expected accrual — eAccrual","text":"eAccrual() computes expected cumulative enrollment (accrual) given set piecewise constant enrollment rates times.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise constant expected accrual — eAccrual","text":"","code":"eAccrual(   x = 0:24,   enrollRates = tibble::tibble(duration = c(3, 3, 18), rate = c(5, 10, 20)) )"},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise constant expected accrual — eAccrual","text":"x times enrollment computed. enrollRates Piecewise constant enrollment rates expressed tibble duration piecewise constant period rate enrollment period.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise constant expected accrual — eAccrual","text":"vector expected cumulative enrollment specified times.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Piecewise constant expected accrual — eAccrual","text":"contents section shown PDF user manual .","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eAccrual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise constant expected accrual — eAccrual","text":"","code":"# Example: default eAccrual() #>  [1]   0   5  10  15  25  35  45  65  85 105 125 145 165 185 205 225 245 265 285 #> [20] 305 325 345 365 385 405"},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected events observed under piecewise exponential model — eEvents_df","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"eEvents_df computes expected events time strata assumption piecewise constant enrollment rates piecewise exponential failure censoring rates. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. intent enable sample size calculations non-proportional hazards assumptions stratified populations.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"eEvents_df(   enrollRates = tibble::tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble::tibble(duration = c(3, 100), failRate = log(2)/c(9, 18),     dropoutRate = rep(0.001, 2)),   totalDuration = 25,   simple = TRUE )"},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"enrollRates Enrollment rates; see details examples failRates Failure rates dropout rates period totalDuration Total follow-start enrollment data cutoff simple default (TRUE), return numeric expected number events, otherwise tibble described .","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"default simple=TRUE return total expected number events real number. Otherwise, simple=FALSE tibble returned following variables period specified 'failRates': t start period, failRate failure rate period Events expected events period, records returned tibble correspond input tibble  failRates.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"periods generally supplied output input. intent enable expected event calculations tidy format maximize flexibility variety purposes.","code":""},{"path":[]},{"path":"https://merck.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"library(tibble) # Default arguments, simple output (total event count only) eEvents_df() #> [1] 57.3537 # Event count by time period eEvents_df(simple=FALSE) #> # A tibble: 2 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0   0.0770   22.2 #> 2     3   0.0385   35.1 # Early cutoff eEvents_df(totalDuration=.5) #> [1] 0.02850923 # Single time period example eEvents_df(enrollRates=tibble(duration=10,rate=10),            failRates=tibble(duration=100,failRate=log(2)/6,dropoutRate=.01),            totalDuration=22,            simple=FALSE            ) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   80.4 # Single time period example, multiple enrolment periods eEvents_df(enrollRates=tibble(duration=c(5,5), rate=c(10,20)),            failRates=tibble(duration=100,failRate=log(2)/6,dropoutRate=.01),            totalDuration=22,            simple=FALSE            ) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   119."},{"path":"https://merck.github.io/gsDesign2/reference/gsDesign2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gsDesign2: Group Sequential Design Under Non-Proportional Hazards — gsDesign2-package","title":"gsDesign2: Group Sequential Design Under Non-Proportional Hazards — gsDesign2-package","text":"Compute sample size non-proportional hazards.","code":""},{"path":[]},{"path":"https://merck.github.io/gsDesign2/reference/gsDesign2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gsDesign2: Group Sequential Design Under Non-Proportional Hazards — gsDesign2-package","text":"Maintainer: Yilong Zhang yilong.zhang@merck.com Authors: Keaven Anderson keaven_anderson@merck.com contributors: Amin Shirazi ashirazist@gmail.com [contributor] Ruixue Wang ruixue.wang@merck.com [contributor] Yi Cui yi.cui@merck.com [contributor] Ping Yang ping.yang1@merck.com [contributor] Xin Tong Li xin.tong.li@merck.com [contributor] Yalin Zhu yalin.zhu@merck.com [contributor] Nan Xiao nan.xiao1@merck.com [contributor] Merck & Co., Inc., Rahway, NJ, USA affiliates [copyright holder]","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise exponential cumulative distribution function — ppwe","title":"Piecewise exponential cumulative distribution function — ppwe","text":"ppwe computes cumulative distribution function (CDF) survival rate piecewise exponential distribution.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise exponential cumulative distribution function — ppwe","text":"","code":"ppwe(   x = 0:20,   failRates = tibble::tibble(duration = c(3, 100), rate = log(2)/c(9, 18)),   lower.tail = FALSE )"},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise exponential cumulative distribution function — ppwe","text":"x times distribution computed. failRates Piecewise constant failure rates rate, duration piecewise constant failure rate period. lower.tail Indicator whether lower (TRUE) upper tail (FALSE; default) CDF computed.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise exponential cumulative distribution function — ppwe","text":"vector cumulative distribution function survival values","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piecewise exponential cumulative distribution function — ppwe","text":"Suppose \\(\\lambda_i\\) failure rate interval \\((t_{-1},t_i], =1,2,\\ldots,M\\) \\(0=t_0<t_i\\ldots,t_M=\\infty\\). cumulative hazard function arbitrary time \\(t>0\\) : $$\\Lambda(t)=\\sum_{=1}^M \\delta(t\\le t_i)(\\min(t,t_i)-t_{-1})\\lambda_i.$$ survival time \\(t\\) $$S(t)=\\exp(-\\Lambda(t)).$$","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Piecewise exponential cumulative distribution function — ppwe","text":"contents section shown PDF user manual .","code":""},{"path":"https://merck.github.io/gsDesign2/reference/ppwe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise exponential cumulative distribution function — ppwe","text":"","code":"# Example: default ppwe(seq(0:10)) #>  [1] 0.9258747 0.8572440 0.7937005 0.7637176 0.7348672 0.7071068 0.6803950 #>  [8] 0.6546923 0.6299605 0.6061630 0.5832645 # Example: plot a survival function with 2 different sets of time values # to demonstrate plot precision corresponding to input parameters. fr <- tibble::tibble(duration=c(3,3,1),rate=c(.2,.1,.005)) Time <- seq(0,10,10/pi) Survival <-  ppwe(Time,fr) plot(Time,Survival,type=\"l\",ylim=c(0,1)) Time <- seq(0,10,.25) Survival <-  ppwe(Time,fr) lines(Time,Survival,col=2)"},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate survival distribution with piecewise exponential distribution — s2pwe","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"s2pwe converts discrete set points arbitrary survival distribution piecewise exponential approximation","code":""},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"","code":"s2pwe(times, survival)"},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"times Positive increasing times survival distribution provided. survival Survival (1 - cumulative distribution function) specified times","code":""},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"tibble containing duration rate.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"contents section shown PDF user manual .#' @return tibble duration 'rate'","code":""},{"path":"https://merck.github.io/gsDesign2/reference/s2pwe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate survival distribution with piecewise exponential distribution — s2pwe","text":"","code":"# Example: arbitrary numbers s2pwe(1:9,(9:1)/10) #> # A tibble: 9 × 2 #>   duration  rate #>      <dbl> <dbl> #> 1        1 0.105 #> 2        1 0.118 #> 3        1 0.134 #> 4        1 0.154 #> 5        1 0.182 #> 6        1 0.223 #> 7        1 0.288 #> 8        1 0.405 #> 9        1 0.693 # Example: lognormal s2pwe(c(1:6,9),plnorm(c(1:6,9),meanlog=0,sdlog=2,lower.tail=FALSE)) #> # A tibble: 7 × 2 #>   duration  rate #>      <dbl> <dbl> #> 1        1 0.693 #> 2        1 0.316 #> 3        1 0.224 #> 4        1 0.177 #> 5        1 0.148 #> 6        1 0.128 #> 7        3 0.103"},{"path":"https://merck.github.io/gsDesign2/reference/tEvents.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict time at which a targeted event count is achieved — tEvents","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tEvents() made match input format AHR() solve time expected accumulated events equal input target. Enrollment failure rate distributions specified follows. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/tEvents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"tEvents(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)     * 5),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   targetEvents = 150,   ratio = 1,   interval = c(0.01, 100) )"},{"path":"https://merck.github.io/gsDesign2/reference/tEvents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict time at which a targeted event count is achieved — tEvents","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. targetEvents targeted number events achieved. ratio Experimental:Control randomization ratio. interval interval presumed include time expected event count equal targetEvents.","code":""},{"path":"https://merck.github.io/gsDesign2/reference/tEvents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tibble Time (computed match events targetEvents), AHR (average hazard ratio), Events (targetEvents input), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input;","code":""},{"path":[]},{"path":"https://merck.github.io/gsDesign2/reference/tEvents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"# Example 1: default tEvents() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  14.9 0.787   150.  36.9  37.5 # Example 2: check that result matches a finding using AHR() # Start by deriving an expected event count enrollRates <-   tibble::tibble(Stratum=\"All\",                  duration=c(2,2,10),                  rate=c(3,6,9)*5) failRates=tibble::tibble(Stratum=\"All\",duration=c(3,100),failRate=log(2)/c(9,18),                          hr=c(.9,.6),dropoutRate=rep(.001,2)) totalDuration <- 20 xx <- AHR(enrollRates,failRates,totalDuration) xx #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    20 0.738   208.  51.0  52.1 # Next we check that the function confirms the timing of the final analysis. tEvents(enrollRates,failRates,targetEvents=xx$Events,interval=c(.5,1.5)*xx$Time) #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  20.0 0.738   208.  51.0  52.1"},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-010-may-2021","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.1.0, May, 2021","title":"gsDesign2 0.1.0, May, 2021","text":"Updated AHR vignette introduce average hazard ratio concept well Added arbitrary distribution vignette demonstrate s2pwe() function Corrected calculations AHR() using stratified population Release Regulatory/Industry Symposium training","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0009006-december-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.9006, December, 2019","title":"gsDesign2 0.0.0.9006, December, 2019","text":"Added eEvents_df() vignette explaining methods thoroughly Updated eEvents_df() simplify output simple=FALSE option","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0009005-december-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.9005, December, 2019","title":"gsDesign2 0.0.0.9005, December, 2019","text":"Updated docs directory correct reference materials web site Minor fix eAccrual","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0009004-november-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.9004, November, 2019","title":"gsDesign2 0.0.0.9004, November, 2019","text":"Moved new simulation functions simtrial package (simfix, simfix2simPWSurv, pMaxCombo).","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0009003-november-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.9003, November, 2019","title":"gsDesign2 0.0.0.9003, November, 2019","text":"Tried make AHR simfix compatible . Improved vignette group sequential design. Added web site documentation vignettes docs/index.html. Added support functions support approximation using visualization piecewise model.","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0002-october-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.2, October, 2019","title":"gsDesign2 0.0.0.2, October, 2019","text":"Update AHR() output trial duration, expected events average hazard ratio tibble. Vignette AHRvignette demonstrating sample size computations fixed design non-proportional hazards assumptions. Vignette gsNPH demonstrating sample size computations group sequential design non-proportional hazards assumptions. Initial implementation pMaxCombo() compute p-value MaxCombo test; pMaxComboVignette demonstrates capability.","code":""},{"path":"https://merck.github.io/gsDesign2/news/index.html","id":"gsdesign2-0001-september-2019","dir":"Changelog","previous_headings":"","what":"gsDesign2 0.0.0.1, September, 2019","title":"gsDesign2 0.0.0.1, September, 2019","text":"Computations based piecewise constant enrollment piecewise exponential failure rate Expected event count calculation different hazard ratios eEvents_df() Average hazard ratio computation based expected event counts AHR() Vignette demonstrating fixed sample size computation simulation verify power","code":""}]
