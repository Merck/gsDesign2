---
title: "Group Sequential Design for Time to Event Outcomes: gsDesign, gsDesign2, and rpact  vs EAST comparison"
output:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: flatly
    code_folding: hide
    number_sections: false
    highlight: "textmate"
    css: "custom.css"
# bibliography: "example.bib"
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Group Sequential Design for Time to Event Outcomes: `gsDesign`, `gsDesign2` vs EAST comparison}
editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
library(tidyr)
library(tibble)
library(gsDesign)
library(gsDesign2)
library(rpact)
library(kableExtra)
library(targets)
library(flextable)
library(details)
options(knitr.table.format = "html", knitr.kable.NA = '')
```

# Overview

TO ADD

# Interim Analysis (IA) for Efficacy

First, we compare the gsDesign, gsDesign2 as well as rpact results to EAST for a scenario where IAs are planned for efficacy only. 

## Working Example

- Phase 3 study with objective to compare experimental therapy to a standard of care (SOC) in cancer patients with respect to progression free survival (PFS) and overall survival (OS). While the study itself is not "real", it mirrors commonly used phase 3 designs in oncology.

- A family of primary endpoints comprises of PFS and OS:
  - PFS is has one IA for both efficacy and futility.
  - OS has two IAs for efficacy only, both for efficacy only.
  
- It is assumed that the initial sample size/power calculations in the protocol are done using EAST.  

### Sample Size Assumptions

- PFS HR=0.6 and median PFS of 9.4 months in the control arm
- OS HR=0.65 and median OS of 3 years in the control arm
-	Enrollment period of 24 months.
- Minimum follow-up of 10 and 44 months for PFS and OS, respectively
- Monthly dropout of 0.019 and 0.001 for PFS and OS, respectively
- 1:1 randomization ratio
- 400 total patients

Target number of events:

- PFS: 236 events with IA at 75% information fraction, 95% power at initially allocated $\alpha$ = 0.0125.
- OS: 219 events with IAs at 60% and 80% information fraction respectively, 82% power at initially allocated $\alpha$ = 0.0125.

### Multiplicity Assumption

TO ADD


## OS Analysis: Efficacy Boundaries and Properties

- Lan-DeMets O’Brien-Fleming alpha-spending function was used to construct the boundaries.

- Efficacy boundaries table calculated using EAST is presented below:


```{r, eval=TRUE}
os_east <- tribble(
  ~analysis, ~value, ~eff_125,  ~eff_25,
  
  'IA3: 60%',   'Z',                   -3.02569409632101,    -2.67335178005868,
  'N=400',      'p (1-sided)',          0.00124031566230105,  0.00375487271138121,
  'Events: 131','HR at bound',          0.589363439145686,    0.626790039898953,
  'Month: 38',  'P(Cross) if HR=1',     0.00124031566236733,  0.00375487271160193, 
  '',           'P(Cross) if HR=0.60',  0.287594389776889,    0.417581743680648,
  
  'IA4: 80%',   'Z',                   -2.58884138850925,    -2.28988990769677,
  'N=400',      'p (1-sided)',          0.00481497196501242,  0.0110138497146098,
  'Events: 175','HR at bound',          0.676112343292131,    0.707371838489819,
  'Month: 50',  'P(Cross) if HR=1',     0.005204198,          0.01216244,
  '',           'P(Cross) if HR=0.60',  0.6078709,            0.7185137,
  
  'FA',         'Z',                    -2.29555066802652,   -2.03037092268016,
  'N=400',      'p (1-sided)',           0.0108507930971346,  0.0211594250017298,
  'Events: 219','HR at bound',           0.733272506020993,   0.760028379543686,
  'Month: 66',  'P(Cross) if HR=1',      0.0125,              0.025,
  '',           'P(Cross) if HR=0.60',   0.8207454,           0.8832428 
  
  
)

os_east |> 
  flextable() |>
  autofit() |>
  set_header_labels(
    analysis = 'Analysis',
     value= 'Value',
     eff_125 = "alpha=0.0125",
     eff_25  = "alpha=0.025"
    ) |>
  hline(i = c(5, 10)) |>
  colformat_double(j = c(3, 4), digits = 4)

```


### Calculations using gsDesign, gsDesign2, and rpact

- `gsDesign::gsSurv()` is used with `test.type = 1` because the OS IAs are for efficacy purpose only.

- It should be noted that EAST returns integer values for the number of events, so that the actual information fraction specified by the user might not __exactly__ match the actual information fraction, calculated by simply dividing the number of events provided by EAST as can be seen below:

```{r,collapse=FALSE}
timing_east_os <- c(131/219, 175/219)
timing_east_os
```


- gsDesign and gsDesign2, on the other hand, provide non-integer values which match __exactly__ the specified information fraction. rpact requires users to specify a design first, including the desired information fraction, `rpact::getDesignGroupSequential()`, which is subsequently used for sample size and power calculations. For a proper comparison between gsDesign, gsDesign2, rpact and EAST we use the exact timing based on the number of events calculated in EAST, i.e., `timing_east_os` object.

#### Power calculations steps

- First we define the relevant input parameters.

```{r}
enroll_dur <- 24
ss <- 400
enroll_rate <- ss/enroll_dur
minfu_os <- 44
fa_time_os <- enroll_dur + minfu_os
failrate_os <- log(2)/36
hr1_os <- 0.65
hr0 <- 1
do_rate_os <- 0.001

#dataframes for inputs to be used in gsDesign2
enrollRates <- tibble(Stratum="All", duration = enroll_dur, rate = enroll_rate)
failRates <- tibble(Stratum="All", 
                    duration=c(fa_time_os), 
                    failRate = failrate_os, 
                    hr = hr1_os, 
                    dropoutRate = do_rate_os)

#the desired alpha level and beta level based on EAST calculations
os_scen <- tibble(
  alevel = c(0.0125, 0.025),
  blevel = c(1 - os_east$eff_125[length(os_east$eff_125)], 1 - os_east$eff_25[length(os_east$eff_25)])
  )
```

- We perform power calculations using `gsDesign::gsSurv()`. Since we need to perform calculations using two levels of $\alpha$ and $\beta$, we use `purrr::map2()` for simplicity.

```{r}
os_gs <-
  os_scen |>
  mutate(
    gs_out = purrr::map2(
      alevel, blevel, function(x, y,...){
        
    out <- gsDesign::gsSurv(
      k = 3,
      timing = timing_east_os,
      R = enroll_dur, 
      gamma = enroll_rate,
      eta =  do_rate_os, 
      minfup = minfu_os,
      T = fa_time_os, 
      lambdaC = failrate_os,
      hr = hr1_os,
      hr0 = 1,
      beta = y,
      alpha = x,
      sfu = gsDesign::sfLDOF,
      sfupar = NULL, 
      test.type = 1
      )
    out |> 
      gsDesign::gsBoundSummary()
     
  }, 
  timing_east_os = timing_east_os, enroll_dur = enroll_dur, 
  do_rate_os = do_rate_os, minfu_os = minfu_os, fa_time_os = fa_time_os,
  failrate_os = failrate_os, hr1_os))
```

- Side-by-side gsDesign results are presented below. The reason these were not combined into one table is because the sample size differs slightly between the two alpha levels.

<div style="float: left; width: 50%;">

```{r}
os_gs |>
  dplyr::filter(alevel == 0.0125) |>
  tidyr::unnest(gs_out) |>
  dplyr::select(-c(alevel, blevel)) |>
  flextable::flextable() |>
  flextable::autofit() |>
  flextable::hline(i = c(5, 10)) |>
  flextable::set_caption(
    as_paragraph(
      "gsDesign results for alpha = 0.0125"
      )
  )

```
</div>

<div style="float: right; width: 50%;">

```{r}
os_gs |>
  dplyr::filter(alevel == 0.025) |>
  tidyr::unnest(gs_out) |>
  dplyr::select(-c(alevel, blevel)) |>
  flextable::flextable() |>
  flextable::autofit() |>
  flextable::hline(i = c(5, 10)) |>
  flextable::set_caption(
    as_paragraph(
      "gsDesign results for alpha = 0.025"
      )
  )

```
</div>

- 

```{r}
os_gs2 <- os_scen |>
  dplyr::mutate(
    gs_out = purrr::map(alevel, function(x,...){
      out <- gsDesign2::gs_power_ahr(
        enrollRates = enrollRates,
        failRates = failRates,
        ratio = 1, 
        events = c(131, 175, 219),
        upper = gs_spending_bound, 
        upar = list(sf = gsDesign::sfLDOF, total_spend = x), 
        test_lower = FALSE
        ) 
      
      summary(out)
    }, enrollRates = enrollRates, failRates = failRates)
  )
#gdDesign2 for alpha = 0.0125
os_gs2_a125 <- gsDesign2::gs_power_ahr(
  enrollRates = enrollRates,
  failRates = failRates,
  ratio = 1, 
  events = c(131, 175, 219),
  upper = gs_spending_bound, 
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.0125), 
  test_lower = FALSE
) 


#gdDesign2 for alpha = 0.025
os_gs2_a25 <- gsDesign2::gs_power_ahr(
  enrollRates = enrollRates,
  failRates = failRates,
  ratio = 1, 
  events = c(131, 175, 219),
  upper = gs_spending_bound, 
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025), 
  test_lower = FALSE
) 

```


```{r}

#map over two values of alpha, rpact:
os_rpact <-  os_scen |>
  dplyr::mutate(
    rpact_out = purrr::map(
      alevel, function(x,...){
        
        out <- 
          getDesignGroupSequential(sided = 1, 
                                   alpha = x,
                                   informationRates = c(timing_east_os, 1), 
                                   typeOfDesign = "asOF")
        
        get_power_out <- getPowerSurvival(
          out, lambda2 = failrate_os, hazardRatio = hr1_os, 
          accrualTime = c(0, enroll_dur), 
          accrualIntensity = enroll_rate, maxNumberOfSubjects = ss,
          dropoutRate1 = 1 - exp(-12*do_rate_os), 
          dropoutRate2 = 1 - exp(-12*do_rate_os), 
          maxNumberOfEvents = 219, directionUpper = FALSE)
        
      },
      timing_east_os = timing_east, failrate_os = failrate_os, hr1_os = hr1_os, 
      enroll_dur = enroll_dur, enroll_rate = enroll_rate, ss = ss, 
      do_rate_os = do_rate_os))
```



<div style="float: left; width: 48%;">
- Summary from `gsDesign2::gs_power_ahr` for $\alpha = 0.0125$:

```{r}
os_gs2$gs_out[os_gs2$alevel == 0.0125] [[1]] |> 
  gsDesign2::as_gt()
```
</div>

<div style="float: right; width: 48%;">
- Summary from `gsDesign2::gs_power_ahr` for $\alpha = 0.025$:

```{r}
os_gs2$gs_out[os_gs2$alevel == 0.025] [[1]] |> 
  gsDesign2::as_gt()
```
</div>

<div style="float: left; width: 45%;">
- Summary from `rpact::getPowerSurvival` for $\alpha = 0.0125$:

```{r, results='asis'}
os_rpact_a125 <- os_rpact |>
  dplyr::filter(alevel == 0.0125) 
os_rpact_a125$rpact_out[[1]] |>
  summary() |>
  rpact::kable(style = "simple")
```
</div>

<div style="float: right; width: 45%;">
- Summary from `rpact::getPowerSurvival` for $\alpha = 0.025$:

```{r, results='asis'}
os_rpact_a25 <- os_rpact |>
  dplyr::filter(alevel == 0.025) 
os_rpact_a25$rpact_out[[1]] |>
  summary() |>
  rpact::kable(style = "simple")  
```
</div>

### Comparison summary between EAST, `gsDesign`, `gsDesign2`, and `rpact``

In the following tables we present a difference in results generated by EAST vs `gsDesign` or vs `gsDesign2` up to the 4th decimal place. Non-zero differences are highlighted in green

- Comparison between EAST vs `gsDesign` and `gsDesign2` for $\alpha = 0.0125$:


```{r, echo=FALSE}
#helper function to align the gsDesign2 summary with gsDesign summary
as_gs <- function(data){
  
  data <- data$bounds
  
  data |>
    dplyr::filter(Bound == 'Upper') |>
    tidyr::pivot_longer(cols = -c(Analysis, Bound), names_to = 'Value', values_to = 'Efficacy') |>
    dplyr::mutate(Value = dplyr::case_when(
      Value == '~HR at bound' ~ 'HR at bound',
      Value == 'Nominal p' ~ 'p (1-sided)',
      Value == 'Probability' ~ 'P(Cross) if HR=0.60',
      Value == 'Probability0' ~ 'P(Cross) if HR=1',
      TRUE ~ Value
    ),
    Value_index = dplyr::case_when(
      Value == 'HR at bound' ~ 3,
      Value == 'p (1-sided)' ~ 2,
      Value == 'P(Cross) if HR=0.60' ~ 5,
      Value == 'P(Cross) if HR=1' ~ 4,
      TRUE ~ 1
    )
    ) |>
    dplyr::arrange(Analysis, Value_index) |>
    dplyr::select(Analysis, Value, Efficacy)
  
}


rpact_as_gs <- function(obj){
  z_out <- tibble::tibble(
    value = rep('Z', 3),
    eff_rpact = obj$.design$criticalValues,
    value_i = rep(1, 3),
    analysis = seq(3)
  )
  
  p_out <- tibble::tibble(
    value = rep('p (1-sided)', 3),
    eff_rpact = obj$.design$stageLevels,
    value_i = rep(2, 3),
    analysis = seq(3)
    
  )
  
  hr_bound <- tibble::tibble(
    value = rep('HR at bound', 3),
    eff_rpact = obj$criticalValuesEffectScale[,1],
    value_i = rep(3, 3),
    analysis = seq(3)
    
  )
  
  p_cross0 <- tibble::tibble(
    value = rep('P(Cross) under H0', 3),
    eff_rpact = obj$.design$alphaSpent,
    value_i = rep(4, 3),
    analysis = seq(3)
    
  )
  
  p_cross1 <- tibble::tibble(
    value = rep('P(Cross) under H1', 3),
    eff_rpact = cumsum(obj$rejectPerStage),
    value_i = rep(5, 3),
    analysis = seq(3)
    
  )
  
  z_out |>
    dplyr::bind_rows(
      p_out, hr_bound, p_cross0, p_cross1
    ) |>
    dplyr::arrange(analysis, value_i) |>
    dplyr::select(-c(value_i))
  
  
}

```


```{r}
os_comp <- function(alpha, east_var, gs2_data, rpact_data){
  os_gs |>
  dplyr::filter(alevel == alpha) |>
  tidyr::unnest(gs_out) |>
  dplyr::select(-c(alevel, blevel)) |>
  dplyr::select(eff_gs = Efficacy) |>
  dplyr::bind_cols(os_east |>
                     dplyr::select(value, analysis, eff_east = all_of(east_var)) |>
                     dplyr::mutate(eff_east = ifelse(value == 'Z', -eff_east, eff_east)),
                   as_gs(gs2_data) |>
                     dplyr::select(eff_gs2 = Efficacy),
                   rpact_as_gs(rpact_data$rpact_out[[1]]) |>
                     dplyr::select(eff_rpact)
                   ) |>
  dplyr::mutate(
    diff_gsDesign =  abs(eff_east - eff_gs),
    diff_gsDesign2 = abs(eff_east - eff_gs2),
    diff_rpact = abs(eff_east - eff_rpact)
    ) |>
  dplyr::select(analysis, value, diff_gsDesign, diff_gsDesign2, diff_rpact) |>
  flextable::flextable() |>
  flextable::autofit() |>
    flextable::set_header_labels(
    analysis = 'Analysis',
    value = 'Value',
    diff_gsDesign = 'EAST vs gsDesign ',
    diff_gsDesign2 = 'EAST vs gsDesign2',
    diff_rpact = 'EAST vs rpact'
  ) |>
  flextable::hline(i = c(5, 10)) |>
  flextable::colformat_double(j = c(3, 4, 5), digits = 4) |>
  flextable::bg(~ round(abs(diff_gsDesign), 4) != 0,  ~ diff_gsDesign, bg = '#6ECEB2') |>
  flextable::bg(~ round(abs(diff_gsDesign2), 4) != 0,  ~ diff_gsDesign2, bg = '#6ECEB2') |>
  flextable::bg(~ round(abs(diff_rpact), 4) != 0,  ~ diff_rpact, bg = '#6ECEB2')
}

os_comp(alpha = 0.0125, east_var = 'eff_125', gs2_data = os_gs2_a125, rpact_data = os_rpact_a125)
```

- Summary from `gsSurv` compared to EAST results for $\alpha = 0.025$:

```{r}
os_comp(alpha = 0.025, east_var = 'eff_25', gs2_data = os_gs2_a25, rpact_data = os_rpact_a25)
```

- Findings:
  - TO BE ADDED

# Interim Analysis for Efficacy and Futility

## PFS Analysis: Efficacy and Futility Boundaries and Properties

- Lan-DeMets O’Brien-Fleming alpha-spending function was used to construct efficacy boundaries.

- Hwang-Shih-DeCani beta-spending function with $\gamma$ = -18 was used to construct futility boundaries.

- Efficacy and futility boundaries table calculated using EAST is presented below:


```{r, eval=TRUE}
pfs_east <- tribble(
  ~analysis, ~value, ~eff_125, ~fut_125,  ~eff_25, ~fut_25,
  
  'IA1: 75%',   'Z',                   -2.65842707203571,    -0.128544419615148,    -2.3397113320164,     0.037962882061965,
  'N=400',      'p (1-sided)',          0.00392531696824894,  0.448859073999353,     0.00964932488140986, 0.515141361748991,
  'Events: 177','HR at bound',          0.670561921102977,    0.980861530765404,     0.703472181733666,   1.0057232454496,
  'Month: 25',  'P(Cross) if HR=1',     0.00392531762987764,  0.55114092599676,      0.0096493248813777,  0.484858638252574,
  '',           'P(Cross) if HR=0.60',  0.77023451062085,     0.000538684816215966,  0.855048656566139,   0.000295175316084,
  
  
  'IA2',         'Z',                    -2.28009247092326,    NA_real_,             -2.01177687012311,   NA_real_,
  'N=400',      'p (1-sided)',           0.0113011023406706,  NA_real_,              0.0221217316007432, NA_real_,
  'Events: 236','HR at bound',           0.743160860965547,   NA_real_,              0.769579482562727,  NA_real_,
  'Month: 34',  'P(Cross) if HR=1',      0.0125,              NA_real_,              0.025,              NA_real_,
  '',           'P(Cross) if HR=0.60',   0.9515091,           NA_real_,              0.973429,           NA_real_
  
  
)

pfs_east |> 
  flextable() |>
  autofit() |>
  set_header_labels(
    analysis = 'Analysis',
     value= 'Value',
     eff_125 = "alpha=0.0125",
     fut_125 = "beta=0.048",
     eff_25  = "alpha=0.025",
     fut_25  = "beta=0.027"
    ) |>
  hline(i = c(5)) |>
  colformat_double(j = c(3, 4, 5, 6), digits = 4)

```

### Calculations using `gsDesign`, `gsDesign2`, and `rpact`

- `gsDesign::gsSurv` is used with `test.type = 4` because PFS is tested for both efficacy and non-binding futiity.

- We will use the exact information fraction as intputs for `gsDesign`, `gsDesign2`, and `rpact`.

```{r,collapse=FALSE}
timing_east_pfs <- c(177/236)
timing_east_pfs
```


```{r}
#define input parameters:
minfu_pfs <- 10
fa_time_pfs <- enroll_dur + minfu_pfs
failrate_pfs <- log(2)/9.4
hr1_pfs <- 0.6
hr0 <- 1
do_rate_pfs <- 0.019


pfs_scen <- tibble(
  alevel = c(0.0125, 0.025),
  blevel = c(1 - pfs_east$eff_125[length(pfs_east$eff_125)], 1 - pfs_east$eff_25[length(pfs_east$eff_25)])
  )

#map over two values of alpha
pfs_gs <-
  os_scen |>
  mutate(
    gs_out = purrr::map2(
      alevel, blevel, function(x, y){
        
    out <- gsSurv(
      k = 2,
      timing = timing_east_pfs,
      R = enroll_dur, 
      gamma = enroll_rate,
      eta =  do_rate_pfs, 
      minfup = minfu_pfs,
      T = fa_time_pfs, 
      lambdaC = failrate_pfs,
      hr = hr1_pfs,
      hr0 = 1,
      beta = y,
      alpha = x,
      sfu = sfLDOF,
      sfupar = NULL, 
      test.type = 4,
      sfl = sfHSD, 
      sflpar = -18
      )
    out |> gsBoundSummary()
     
  }))

#dataframes for inputs to be used in gsDesign2 below
enrollRates <- tibble(Stratum="All", duration = enroll_dur, rate = enroll_rate)
failRates_pfs <- tibble(Stratum="All", 
                    duration=c(fa_time_pfs), 
                    failRate = failrate_pfs, 
                    hr = hr1_pfs, 
                    dropoutRate = do_rate_pfs)

# pfs_gs2_a125 <- gsDesign2::gs_power_ahr(
#   enrollRates = enrollRates,
#   failRates = failRates+pfs,
#   ratio = 1, 
#   events = c(177, 236),
#   upper = gs_spending_bound, 
#   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.0125), 
#   test_lower = FALSE
# ) 
# 
# os_gs2_a25 <- gsDesign2::gs_power_ahr(
#   enrollRates = enrollRates,
#   failRates = failRates,
#   ratio = 1, 
#   events = c(131, 175, 219),
#   upper = gs_spending_bound, 
#   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025), 
#   test_lower = FALSE
# ) 

```
