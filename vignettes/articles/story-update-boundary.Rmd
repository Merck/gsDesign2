---
title: "Efficacy and futility boundary update"
author: "Yujie Zhao and Keaven M. Anderson"
output:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    highlight: "textmate"
    css: "custom.css"
bibliography: "gsDesign2.bib"
vignette: >
  %\VignetteIndexEntry{Efficacy and futility boundary update}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(gsDesign2)
library(tibble)
library(gt)
library(dplyr)
```

# Design assumptions

We assume two analyses: an interim analysis (IA) and a final analysis (FA).
The IA is planned 20 months after opening enrollment, followed by the FA at
month 36.
The planned enrollment period spans 14 months, with the first 2 months having
an enrollment rate of 1/3 the final rate, the next 2 months with a rate of 2/3
of the final rate, and the final rate for the remaining 10 months.
To obtain the targeted 90\% power, these rates will be multiplied by a constant.
The control arm is assumed to follow an exponential distribution with a median
of 9 months and the dropout rate is 0.0001 per month regardless of treatment group.
Finally, the experimental treatment group is piecewise exponential with a
3-month delayed treatment effect; that is, in the first 3 months HR = 1 and
the HR is 0.6 thereafter.

```{r}
alpha <- 0.025
beta <- 0.1
ratio <- 1

# Enrollment
enroll_rate <- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = (1:3) / 3
)

# Failure and dropout
fail_rate <- define_fail_rate(
  duration = c(3, Inf),
  fail_rate = log(2) / 9,
  hr = c(1, 0.6),
  dropout_rate = .0001
)
# IA and FA analysis time
analysis_time <- c(20, 36)

# Randomization ratio
ratio <- 1
```

We use the null hypothesis information for boundary crossing probability
calculations under both the null and alternate hypotheses.
This will also imply the null hypothesis information will be used for the
information fraction used in spending functions to derive the design.

```{r}
info_scale <- "h0_info"
```

# One-sided design {.tabset}

For the design, we have efficacy bounds at both the IA and FA.
We use the @lan1983discrete spending function with a total alpha of `r alpha`,
which approximates an O'Brien-Fleming bound.

## Planned design

```{r}
upper <- gs_spending_bound
upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)

x <- gs_design_ahr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  alpha = alpha,
  beta = beta,
  info_frac = NULL,
  info_scale = "h0_info",
  analysis_time = analysis_time,
  ratio = ratio,
  upper = gs_spending_bound,
  upar = upar,
  test_upper = TRUE,
  lower = gs_b,
  lpar = rep(-Inf, 2),
  test_lower = FALSE
) |> to_integer()
```

The planned design targets:

- Planned events: `r round(x$analysis$event, 0)`
- Planned information fraction for interim and final analysis: `r round(x$analysis$info_frac, 4)`
- Planned alpha spending: `r round(gsDesign::sfLDOF(0.025, x$analysis$info_frac)$spend, 4)`
- Planned efficacy bounds: `r round(x$bound$z[x$bound$bound == "upper"], 4)`

We note that rounding up the final targeted events increases power slightly
over the targeted 90\%.

```{r}
x |>
  summary() |>
  as_gt() |>
  gt::tab_header(title = "Original design") |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "lightcyan"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )
  )
```

## Blinded estimation of AHR 


We provide a simulation below where 188 and 295 events observed at the IA and FA, respectively.
We will assume the differences from planned (193, 297) are due to logistical considerations.
We also assume the protocol specifies that the full $\alpha$ will be spent at
the final analysis even in a case like this where there is a shortfall of events
versus the design plan.

The observed data for this example is generated by `simtrial::sim_pw_surv()`.

```{r}
set.seed(123)

observed_data <- simtrial::sim_pw_surv(
  n = x$analysis$n[x$analysis$analysis == 2],
  stratum = data.frame(stratum = "All", p = 1),
  block = c(rep("control", 2), rep("experimental", 2)),
  enroll_rate = x$enroll_rate,
  fail_rate = (fail_rate |> simtrial::to_sim_pw_surv())$fail_rate,
  dropout_rate = (fail_rate |> simtrial::to_sim_pw_surv())$dropout_rate
)
```

To calculate the blinded estimation of AHR (i.e., `theta1`), we have 2 options. Both options yield the same results. 
Option 1 is useful when the event counts are available or when the methods need explanation.
Option 2 is simple for scenarios where time-to-event data is available as a single function call is needed to get the needed `theta1` and AHR for each analysis.

### Option 1

We summarize event counts by HR interval for each analysis.

```{r}
counts_table <- NULL
# Cut points for hazard rate intervals specified
t_cut <- c(0, cumsum(fail_rate$duration))
for (i in seq_along(analysis_time)) {
  observed_data_i <- observed_data |> simtrial::cut_data_by_date(analysis_time[i])
  for (j in seq_along(nrow(fail_rate))) {
    events <- sum(observed_data_i$event * (observed_data_i$tte > t_cut[j]) * (observed_data_i$tte <= t_cut[j + 1]))
    counts_table <- rbind(counts_table,
                          tibble(Analysis = i, Interval = j, Events = events, HR = fail_rate$hr[j]))
  }
}
counts_table |> gt() |> tab_header("Counts by HR interval for each analysis")

event_observed <- (counts_table |> group_by(Analysis) |> summarise(event = sum(Events)))$event
```

This can be converted to a blinded estimate of AHR and standardized effect size `theta` as follows:
We let $j$ index analyses and $i$ index the constant failure rate intervals input in `fail_rate` above.
The basic computation is based on the number of events in each of the $i$ intervals at each analysis.
We denote the assumed hazard ratio in interval $i$ as $\text{HR}_i$
For analysis $j$

$$
  -\log(\text{AHR}_j) = -\log(\sum_{i=1}^m w_{ij} \; \text{HR}_i),
$$
where the weight is determined by the ratio of observed number of events occurring in each constant hazard rate interval at 
analysis $j$ divided by the observed total events at analysis $j$.

```{r}
blinded_ahr <- counts_table |>
  group_by(Analysis) |>
  summarize(theta = -sum(Events * log(HR)) / sum(Events),
            AHR = exp(-theta),
            Events = sum(Events),
            info0 = Events * x$input$ratio / (1 + x$input$ratio)^2)

blinded_ahr |>
  gt() |>
  tab_header("Blinded AHR estimate for each analysis") |>
  fmt_number(columns = c("theta", "AHR"), decimals = 3) |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "#009999"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = theta,
      rows = everything()
    )
  )
```









- **Option 2:** we use the blinded data to estimate the AHR and `theta1` is the
  negative logarithm of the estimated AHR.

```{r}
# theta1 at IA
observed_data_ia <- observed_data |> simtrial::cut_data_by_date(analysis_time[1])

blinded_ahr_ia <- ahr_blinded(surv = survival::Surv(time = observed_data_ia$tte, event = observed_data_ia$event),
                              intervals = c(3, x$analysis$time[1]),
                              hr = c(1, 0.6),
                              ratio = 1)

# theta1 at FA
observed_data_fa <- observed_data |> simtrial::cut_data_by_date(analysis_time[2])

blinded_ahr_fa <- ahr_blinded(surv = survival::Surv(time = observed_data_fa$tte, event = observed_data_fa$event),
                              intervals = c(3, x$analysis$time[2]),
                              hr = c(1, 0.6),
                              ratio = 1)

# Combine both IA and FA
blinded_ahr <- rbind(blinded_ahr_ia, blinded_ahr_fa)
blinded_ahr |>
  gt() |>
  tab_header("Blinded AHR estimates from ahr_blinded()") |>
  gt::tab_style(style = list(gt::cell_fill(color = "#009999"), gt::cell_text(weight = "bold")),
                locations = gt::cells_body(columns = theta, rows = everything()))
```



## Updating the design {.tabset}

We compute boundary crossing probabilities under H0 and H1 separately. 

### H0

We will utilize the `gs_power_npe()` function to update efficacy bounds
based on the observed events.
The details of arguments and implementation are explained in the Appendix.

```{r}
upar_update <- x$input$upar
# Now update timing parameter for the interim analysis.
# Interim spending based on observed events divided by final planned events.
# The remaining alpha will be allocated to FA.
upar_update$timing <- c(event_observed[1] / max(x$analysis$event), 1)

x_updated_h0 <- gs_power_npe(
  # `theta = 0` provides the crossing probability under H0
  theta = 0,
  # Observed statistical information under H0
  info = blinded_ahr$info0,
  info_scale = "h0_info",
  # Upper bound uses spending function from planned design
  upper = x$input$upper,
  upar = upar_update,
  test_upper = x$input$test_upper,
  # No lower bound, but copy this from input
  lower = x$input$lower,
  lpar = x$input$lpar,
  test_lower = x$input$test_lower,
  # Binding
  binding = x$input$binding
)
```

The updated efficacy bounds are `r round(x_updated_h0$z[x_updated_h0$bound == "upper"], 3)`.

### H1

To calculate power of the updated boundaries, we use `gs_power_npe`. Different from crossing probability under H0 with `theta= 0` in `gs_power_npe`, we update the value of `theta` to the treatment effect under H1. 

A value of `theta1` is computed with one of the blinded AHR methods above and incorporated below.
```{r}
x_updated_h1 <- gs_power_npe(
  # An `theta` under H1 provides the power of the updated boundaries
  theta = blinded_ahr$theta,
  # Observed statistical information under H0,
  # same as info = event_observed * x$input$ratio / (1 + x$input$ratio)^2
  info = blinded_ahr$info0,
  info_scale = "h0_info",
  # Upper bound uses updated efficacy bounds
  upper = gs_b,
  upar = x_updated_h0$z[x_updated_h0$bound == "upper"],
  test_upper = x$input$test_upper,
  # No lower bound, but copy this from input
  lower = x$input$lower,
  lpar = x$input$lpar,
  test_lower = x$input$test_lower,
  # Binding
  binding = x$input$binding
)
```

### Summary table

Now we combine the results under H0 and H1 for a complete summary table. 

```{r}
# Tidy summary table for the updated design
table_a <- tibble(Analysis = x_updated_h0$analysis[1:2],
                  N = x$analysis$n,
                  `Observed Events` = blinded_ahr$event,
                  `Information fraction` = x_updated_h0$info_frac[1:2])

table_b <- tibble(Analysis = x_updated_h0$analysis[1:2],
                  Bound = x_updated_h0$bound[1:2],
                  Z = x_updated_h0$z[1:2],
                  `~HR at bound` = exp(-Z / sqrt(x_updated_h0$info0[1:2])),
                  `Nominal p` = pnorm(-Z),
                  `Alternate hypothesis` = x_updated_h1$probability[1:2],
                  `Null hypothesis` = x_updated_h0$probability[1:2])

gsDesign2:::table_ab(table_a = table_a,
                     table_b = table_b,
                     decimals = c(0, 0, 0, 2),
                     byvar = "Analysis") |>
  mutate(Bound = recode(Bound, "upper" = "Efficacy")) |>
  group_by(Analysis) |>
  gt() |>
  tab_header(title = "Updated design", subtitle = "by event fraction based timing") |>
  tab_spanner(columns = c(`Alternate hypothesis`, `Null hypothesis`),
              label = "Cumulative boundary crossing probability") |>
  fmt_number(columns = 3:7,
             decimals = 4) |>
  gt::tab_style(
    style = list(gt::cell_fill(color = "lightcyan"),
                 gt::cell_text(weight = "bold")),
    locations = gt::cells_body(columns = Z, rows = Bound == "Efficacy")
  )
```


# Two-sided asymmetric design, beta-spending with non-binding lower bound {.tabset}

In this section, we investigate a 2 sided asymmetric design, with the
non-binding beta-spending futility bounds. Beta-spending refers to
error spending for the lower bound crossing probabilities under the
alternative hypothesis. Non-binding assumes the trial continues if the
lower bound is crossed for Type I, but not Type II error computation.

## Planned design

In the original designs, we employ the Lan-DeMets spending function used to
approximate O'Brien-Fleming bounds [@lan1983discrete] for both efficacy and
futility bounds.
The total spending for efficacy is `r alpha`, and for futility is `r beta`.
Besides, we assume the futility test only happens at IA.

```{r}
upper <- gs_spending_bound
upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)
lower <- gs_spending_bound
lpar <- list(sf = gsDesign::sfLDOF, total_spend = beta, param = NULL)

x <- gs_design_ahr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  alpha = alpha,
  beta = beta,
  info_frac = NULL,
  info_scale = "h0_info",
  analysis_time = c(20, 36),
  ratio = ratio,
  upper = gs_spending_bound,
  upar = upar,
  test_upper = TRUE,
  lower = lower,
  lpar = lpar,
  test_lower = c(TRUE, FALSE),
  binding = FALSE
) |> to_integer()
```

In the planned design, we have

- Planned events: `r round(x$analysis$event, 0)`
- Planned information fraction (timing): `r round(x$analysis$info_frac, 4)`
- Planned alpha spending: `r gsDesign::sfLDOF(0.025, x$analysis$info_frac)$spend`
- Planned efficacy bounds: `r round(x$bound$z[x$bound$bound == "upper"], 4)`
- Planned futility bounds: `r round(x$bound$z[x$bound$bound == "lower"], 4)`

Since we added futility bounds, the sample size and number of events are
larger than what we have in the 1-sided example.

```{r}
x |>
  summary() |>
  as_gt() |>
  gt::tab_header(title = "Original design") |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "lightcyan"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )
  ) |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "#F9E3D6"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Futility"
    )
  )
```

For simplicity in presentation, we assume the observed events are the same as that in the 1-sided design.  

### Updated efficacy and futility bounds and crossing probability under H0

Again, we use `gs_power_npe()` to calculate the updated efficacy and futility bounds.
The details of its arguments and implementations are explained in the Appendix.
We initially set up `theta = 0` for crossing probability under the null hypothesis
and `theta0 = 0` for null hypothesis.
We use the same `theta1` we calculated previously.

```{r}
upar_update  <- upar
upar_update$timing <- c(event_observed[1] / max(x$analysis$event), 1)
lpar_update <- lpar
lpar_update$timing <- c(event_observed[1] / max(x$analysis$event), 1)
x_updated_h0 <- gs_power_npe(
  # `theta = 0` provides the crossing probability under H0.
  # Users have the flexibility to modify the value of `theta`,
  # if they are interested in the crossing probability under H1 or other scenarios.
  theta = 0,
  # -log(AHR) = 0 for H0 is used for determining upper spending
  theta0 = 0,
  # -log(AHR) for H1 is used for determining the lower spending and bounds
  theta1 = blinded_ahr$theta,
  # Observed statistical information under H0 with equal randomization
  info = blinded_ahr$info0,
  # Upper bound
  upper = x$input$upper,
  upar = upar_update,
  test_upper = TRUE,
  # Lower bound
  lower = x$input$lower,
  lpar = lpar_update,
  test_lower = c(TRUE, FALSE),
  binding = x$input$binding
)
```

The updated efficacy bounds are `r round(x_updated_h0$z[x_updated_h0$bound == "upper"], 3)`, and the updated futility bounds are `r round(x_updated_h0$z[x_updated_h0$bound == "lower"], 3)`.

### Crossing probability under H1

Following the same argument in the 1-sided design, we can calculate the updated power as

```{r}
x_updated_h1 <- gs_power_npe(
  # An `theta` under H1 provides the power of the updated boundaries
  theta = blinded_ahr$theta,
  # Observed statistical information under H0
  info = blinded_ahr$info0,
  info_scale = "h0_info",
  # Upper bound uses updated efficacy bounds
  upper = gs_b,
  upar = x_updated_h0$z[x_updated_h0$bound == "upper"],
  test_upper = x$input$test_upper,
  # Lower bound uses updated futility bounds
  lower = gs_b,
  lpar = x_updated_h0$z[x_updated_h0$bound == "lower"],
  test_lower = x$input$test_lower,
  # Binding
  binding = x$input$binding
)
```

### Summary table


```{r}
# Tidy summary table for the updated design
table_a <- tibble(Analysis = x_updated_h0$analysis[1:2],
                  N = x$analysis$n,
                  `Observed Events` = blinded_ahr$event,
                  `Information fraction` = x_updated_h0$info_frac[1:2])

table_b <- tibble(Analysis = x_updated_h0$analysis,
                  Bound = x_updated_h0$bound,
                  Z = x_updated_h0$z,
                  `~HR at bound` = exp(-Z / sqrt(x_updated_h0$info0)),
                  `Nominal p` = pnorm(-Z),
                  `Alternate hypothesis` = x_updated_h1$probability,
                  `Null hypothesis` = x_updated_h0$probability)

gsDesign2:::table_ab(table_a = table_a,
                     table_b = table_b,
                     decimals = c(0, 0, 0, 2),
                     byvar = "Analysis") |>
  mutate(Bound = recode(Bound, "upper" = "Efficacy", "lower" = "Futility")) |>
  group_by(Analysis) |>
  filter(!is.infinite(Z)) |>
  gt() |>
  tab_header(title = "Updated design", subtitle = "by event fraction based timing") |>
  tab_spanner(columns = c(`Alternate hypothesis`, `Null hypothesis`),
              label = "Cumulative boundary crossing probability") |>
  fmt_number(columns = 3:7,
             decimals = 4) |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "lightcyan"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )
  ) |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "lightcyan"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )
  ) |>
  gt::tab_style(
    style = list(
      gt::cell_fill(color = "#F9E3D6"),
      gt::cell_text(weight = "bold")
    ),
    locations = gt::cells_body(
      columns = Z,
      rows = Bound == "Futility"
    )
  )
```


# Appendix

## Arguments of `gs_power_npe()`

We provide an introduction to its arguments.

- *3 theta-related arguments*:
  - `theta`: a vector with the natural parameter for the group sequential design;
    represents expected ; $-\log(\text{AHR})$ in this case.
    This is used for boundary crossing probability calculation.
    For example, if we set `theta = 0`, then the crossing probability is the
    Type I error.
  - `theta0`: natural parameter for H0; used for determining the upper
    (efficacy) spending and bounds. If the default of `NULL` is given,
    then this is replaced by 0.
  - `theta1`: natural parameter for H1; used for determining the lower spending
    and bounds. The default is `NULL`, in which case the value is replaced with
    the input `theta`.

- *3 statistical information-related arguments*:
  - `info`: statistical information at all analyses for input `theta`.
    Default is `1`.
  - `info0`: statistical information under H0, if different than `info`.
    It impacts null hypothesis bound calculation. Default is `NULL`.
  - `info1`: statistical information under hypothesis used for futility bound
    calculation if different from `info`. It impacts futility hypothesis bound
    calculation. Default is `NULL`.

- *Efficacy/Futility boundary-related arguments*:
  - `upper`, `upar` and `test_upper`: efficacy bounds related, same as `gs_design_ahr()`.
  - `lower`, `lpar` and `test_lower`: futility bounds related, same as `gs_design_ahr()`.
  - `binding`: `TRUE` or `FALSE` indicating whether it is binding or non-binding designs.

## Statistical information under H0

In this section, we discuss the values of the `info` arguments
for the input `theta = 0` of `gs_power_npe`. Since the statistical information is event-based,
and `theta = 0` (null hypothesis), the observed statistical information
under null hypothesis is

$$
  \text{observed number of events} \times \frac{r}{1 + r} \times \frac{1}{1 + r},
$$

where $r$ is the randomization ratio (experimental : control).
In this example, the observed statistical information is calculated as
`info = event_observed / 4`, and thus, we input `r event_observed / 4`
for the `info` argument. In this case, we retain the default imputed value
for `info0`, which is set as `info`. The `info` represents the
statistical information under the null hypothesis (`theta = 0`).
Furthermore, we leave `info1` as it is, considering our focus on efficacy bounds,
while noting that `info1` does affect the futility bounds.


# References
