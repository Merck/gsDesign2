---
title: "Efficacy and Futility Boundary Update"
author: "Yujie Zhao and Keaven M. Anderson"
output:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    highlight: "textmate"
    css: "custom.css"
bibliography: "gsDesign2.bib"
vignette: >
  %\VignetteIndexEntry{Efficacy and Futility Boundary Update}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(gsDesign)
library(gsDesign2)
library(gt)
library(tibble)
library(dplyr)
```

# Design assumptions

We assume a total of two analyses, including a final Analysis (FA). The initial Analysis (IA) occurs at month 20, followed by the FA at month 36. The enrollment period spans 14 months, with the first 2 months having an enrollment rate of 3, the next 2 months with a rate of 6, and the final 10 months with a rate of 9. The planned enrollment rate to achieve the 90\% power is a multiptier of 3, 6, and 9. Additionally, there is a delayed treatment effect in the first 3 months (HR = 1), which transitions to an HR of 0.6 thereafter. The median of the control arm is 9 months, and the dropout rate is 0.0001.

```{r, echo=FALSE}
alpha <- 0.025
beta <- 0.1
ratio <- 1

# enrollment
enroll_rate <- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9))

# failure and dropout
fail_rate <- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / 9,
  hr = c(1, 0.6),
  dropout_rate = .0001)
```

# One-sided design {.tabset}

In this example, we have efficacy bounds at both the IA and FA. The spending function used is the @lan1983discrete spending function with a total alpha of `r alpha`, which approximates an O'Brien-Fleming bound.

## Planed design

```{r}
upper <- gs_spending_bound
upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)

x <- gs_design_ahr(
    enroll_rate = enroll_rate,
    fail_rate = fail_rate,
    alpha = alpha, 
    beta = beta,
    info_frac = NULL, 
    analysis_time = c(20, 36),
    ratio = ratio, 
    upper = gs_spending_bound,
    upar = upar,
    test_upper = TRUE,
    lower = gs_b,
    lpar = rep(-Inf, 2),
    test_lower = FALSE) |> to_integer()
```

In the planed design, we have 

- planned events: `r round(x$analysis$event, 0)`
- planned information fraction (timing): `r round(x$analysis$info_frac, 4)`
- planned alpha spending: `r sfLDOF(0.025, x$analysis$info_frac)$spend`
- planned efficacy bounds: `r round(x$bound$z[x$bound$bound == "upper"], 4)`

```{r, echo=FALSE}
x |> 
  summary() |> 
  gt() |>
  tab_header(title = "Original design") |>
  tab_style(
    style = list(
      cell_fill(color = "lightcyan"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )) |>
  tab_style(
    style = list(
      cell_fill(color = "#F9E3D6"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = Z,
      rows = Bound == "Futility"
    )
  )
```

## Update bounds at time of analysis 

Assume in practice, there are 180 and 280 events observed in IA and FA, respectively. 

```{r, echo=FALSE}
# observed vs. planned events
event_observed <- c(180, 280)
event_planned <- x$analysis$event

tibble(Analysis = c("IA", "FA"),
       `Planned number of events` = event_planned,
       `Observed number of events` = event_observed) |> 
  gt() |> 
  tab_header("Planned vs. Observed events")
```

Considering the observed number of events mentioned above, we utilize the `gs_power_npe()` function to generate updated efficacy bounds. As `gs_power_npe()` is a lower-level function that may be unfamiliar to some users, we will start by providing an introduction to its arguments as preliminaries.

- *3 theta-related arguments*:
  + `theta`: natural parameter for group sequential design representing expected incremental drift at all analyses, i.e., $-\log(\text{AHR})$. It is used for crossing probability calculation. For example, if we set `theta = 0`, then the crossing probability is the type I error. Default is `0.1`.
  + `theta0`: natural parameter for H0 and it decides the upper bounds. Default is `NULL`.
  + `theta1`: natural parameter for H1 and it decides the lower bounds. Default is `NULL`.
  
- *3 statistical information-related arguments*:
  + `info`: statistical information at all analyses for input `theta`. Default is `1`.
  + `info0`: statistical information under H0, if different than `info`. It impacts null hypothesis bound calculation. Default is `NULL`.
  + `info1`: statistical information under hypothesis used for futility bound calculation if different from `info`. It impacts futility hypothesis bound calculation. Default is `NULL`.
  
- *Efficacy/Futility boundary-related arguments*:
  + `upper`, `upar` and `test_upper`: efficacy bounds related, same as `gs_design_ahr()`.
  + `lower`, `lpar` and `test_lower`: futility bounds related, same as `gs_design_ahr()`.
  + `binding`: `TRUE` or `FALSE` indicating whether it is binding or non-binding designs. 
  
When implementing `gs_power_npe()`, we initially set up `theta = 0`, which provides the crossing probability under the null hypothesis. Users have the flexibility to modify the value of `theta` if they are interested in the crossing probability under alternative hypotheses or other scenarios. In this implementation, we leave the setup of `theta0` with its default imputed value of `0`, indicating the null hypothesis. Additionally, as we are solely dealing with efficacy bounds, we do not adjust `theta1`, which influences the futility bound.

Moving forward, we proceed to set up the values of the `info` arguments for the input `theta = 0`. Since the statistical information is event-based, and `theta = 0` (null hypothesis), the observed statistical information under null hypothesis is 
$$
  \text{observed number of events} \times \frac{r}{1 + r} \times \frac{1}{1 + r},
$$
where $r$ is the randomization ratio (experimental : control). In this example, the observed statistical information is calculated as `info = event_observed / 4`, and thus, we input `r event_observed / 4` for the `info` argument. In this case, we retain the default imputed value for `info0`, which is set as `info`. The `info` represents the statistical information under the null hypothesis (`theta = 0`). Furthermore, we leave `info1` as it is, considering our focus on efficacy bounds, while noting that `info1` does affect the futility bounds.

Lastly, we establish the parameters for the upper and lower bounds. The setup of `upper`, `upar`, `test_upper`, `lower`, `lpar`, and `test_lower` closely resembles the original design, with the exception of the `upar` setup. Here, we have introduced the `timing = ...` parameter. At the IA, the observed number of events is `r event_observed[1]`. If we employ the interim analysis alpha spending strategy, the spending timing at IA is calculated as `r event_observed[1]` / `r round(event_planned[2], 0)`. Here, `r round(event_planned[2], 0)` represents the planned number of events at FA. The remaining alpha will be allocated to the FA stage.

```{r}
x_updated <- gs_power_npe(
  # theta
  theta = 0,
  # info
  info  = event_observed / 4, 
  # upper bound
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, 
              total_spend = alpha, 
              param = NULL, 
              timing = c(event_observed[1] / max(event_planned), 1)),
  test_upper = TRUE,
  # lower bound
  lower = gs_b,
  lpar = rep(-Inf, 2),
  test_lower = FALSE,
  # binding
  binding = FALSE)
```
So the updated efficacy bounds are `r x_updated$z[x_updated$bound == "upper"]`.
```{r, echo=FALSE}
x_updated |> 
  filter(bound == "upper") |>
  gt() |>
  tab_header(title = "Updated design", 
             subtitle = paste0("with observed ", paste(event_observed, collapse = ", "), " events")) |>
  tab_style(
    style = list(
      cell_fill(color = "lightcyan"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = z,
      rows = bound == "upper"
    )
  ) |>
  tab_footnote(footnote = "Crossing pbability under H0.", locations = cells_column_labels(columns = probability))
```

# Two-sided asymmetric design, beta-spending with non-binding lower bound {.tabset}

In this section, we investigate a 2 sided asymmetric design, with the non-binding beta-spending futility bounds. Beta-spending refers to error spending for the lower bound crossing probabilities under the alternative hypothesis. Non-binding assumes the trial continues if the lower bound is crossed for Type I and Type II error computation. 

## Planed design

In the original designs, we employ the Lan DeMets O'Brien-Fleming spending function [@lan1983discrete] for both efficacy and futility bounds. The total spending for efficacy is `r alpha`, and for futility is `r beta`. Besides, we assume the futility test only happens at IA. 

```{r}
upper <- gs_spending_bound
upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)
lower <- gs_spending_bound
lpar <- list(sf = gsDesign::sfLDOF, total_spend = beta, param = NULL) 

x <- gs_design_ahr(
    enroll_rate = enroll_rate,
    fail_rate = fail_rate,
    alpha = alpha, 
    beta = beta,
    info_frac = NULL, 
    analysis_time = c(20, 36),
    ratio = ratio, 
    upper = gs_spending_bound,
    upar = upar,
    test_upper = TRUE,
    lower = lower,
    lpar = lpar,
    test_lower = c(TRUE, FALSE),
    binding = FALSE) |> to_integer()
```

In the planed design, we have 

- planned events: `r round(x$analysis$event, 0)`
- planned information fraction (timing): `r round(x$analysis$info_frac, 4)`
- planned alpha spending: `r sfLDOF(0.025, x$analysis$info_frac)$spend`
- planned efficacy bounds: `r round(x$bound$z[x$bound$bound == "upper"], 4)`
- planned futility bounds: `r round(x$bound$z[x$bound$bound == "lower"], 4)`

Since we added futility bounds, the sample size and number of events are larger than what we have in the 1-sided example. 
```{r, echo=FALSE}
x |> 
  summary() |> 
  gt() |>
  tab_header(title = "Original design") |>
  tab_style(
    style = list(
      cell_fill(color = "lightcyan"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = Z,
      rows = Bound == "Efficacy"
    )) |>
  tab_style(
    style = list(
      cell_fill(color = "#F9E3D6"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = Z,
      rows = Bound == "Futility"
    )
  )
```

## Update bounds at time of analysis 

In practice, let us assume that there were 180 events observed at IA stage and 280 events at the FA stage.

```{r, echo=FALSE}
# observed vs. planned events
event_observed <- c(180, 280)
event_planned <- x$analysis$event

tibble(Analysis = c("IA", "FA"),
       `Planned number of events` = event_planned,
       `Observed number of events` = event_observed) |> 
  gt() |>
  tab_header("Planned vs. Observed events")
```

Again, we use `gs_power_npe()` to calculate the updated efficacy and futility bounds. We initially set up `theta = 0`, which provides the crossing probability under the null hypothesis. Users have the flexibility to modify the value of `theta` if they are interested in the crossing probability under alternative hypotheses or other scenarios. We set up `theta0 = 0` for null hypothesis. In this implementation, we set up `theta1` as the weighted average of the piecewise HR, i.e., 
$$
  -\log(\text{AHR}) = -\log(\sum_{i=1}^m \text{HR}_m),
$$
where the weight is decided by the observed number of events. For example, assume there are 50 events observed at the first 3 months (HR = 1), and 150 events observed after 3 months (HR = 0.6), we can derive `theta1` as $-\left[\frac{50}{280} \times \log(1) + \frac{230}{280} \times \log(0.6)\right]$.

Moving forward, we proceed to set up the values of the `info` arguments for the input `theta = 0`. Similar to the examples in the 1-sided design above, we set `info` as `r event_observed`/4, where `r event_observed` is the observed number of events. Because `info0` is under null hypothesis, we leave it and use its default imput values same as `info`. Furthermore, we leave `info1` as its default imput values same as `info` with the local null hypothesis approach. Though people can explictly write the formula of `info1` in terms of the observed events, but it would be easiest with unblinded data which we probably don't want to get into using.

Lastly, we establish the parameters for the upper and lower bounds. The setup of `upper`, `upar`, `test_upper`, `lower`, `lpar`, and `test_lower` closely resembles the original design, with the exception of the `upar` and `lpar` setup. Here, we have introduced the `timing = ...` parameter. At the IA, the observed number of events is `r event_observed[1]`. If we employ the interim analysis alpha spending strategy, the spending timing at IA is calculated as `r event_observed[1]` / `r round(event_planned[2], 0)`. Here, `r round(event_planned[2], 0)` represents the planned number of events at FA. The remaining alpha will be allocated to the FA stage.

```{r}
x_updated <- gs_power_npe(
  # theta
  theta = 0,
  theta0 = 0,
  theta1 = -(50 * log(1) + 230 * log(0.6))/280,
  # info, # ?? shall we set up info1?
  info  = event_observed / 4, 
  # upper bound
  upper = x$input$upper,
  upar = list(sf = gsDesign::sfLDOF, 
              total_spend = alpha, 
              param = NULL, 
              timing = c(event_observed[1] /  max(event_planned), 1)),
  test_upper = TRUE,
  # lower bound
  lower = x$input$lower,
  lpar = list(sf = gsDesign::sfLDOF, 
              total_spend = beta, 
              param = NULL, 
              timing = c(event_observed[1] /  max(event_planned), 1)),
  test_lower = c(TRUE, FALSE),
  binding = x$input$binding)
```

```{r, echo=FALSE}
x_updated |> 
  gt() |>
  tab_header(title = "Updated design", subtitle = "by event fraction based timing") |>
  tab_style(
    style = list(
      cell_fill(color = "lightcyan"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = probability,
      rows = bound == "upper"
    )
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "#F9E3D6"),
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = probability,
      rows = bound == "lower"
    )
  )
```






# References
