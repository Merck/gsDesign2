#  Copyright (c) 2024 Merck & Co., Inc., Rahway, NJ, USA and its affiliates.
#  All rights reserved.
#
#  This file is part of the gsDesign2 program.
#
#  gsDesign2 is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' Conditional power computation for group sequential designs using the average hazard ratio method.
#'
#' @param x A design object of type `gs_design_ahr()`,  `gs_power_ahr()`, or `gs_update_ahr()`.
#' @param i Analysis at which interim z-value is given; must be from 1 to `nrow(x$analysis) - 1`.
#' @param z_i Interim z-value at analysis `i` (scalar).
#' @param hr_future A scalar or vector, which specifies the natural parameter for treatment effect at the future analyses.
#' The default gives you a range of possible HRs from 0.6 to 1.
#'
#' @return A data frame showing the conditional power based on the input design, interim test statistic, and possible future HR.
#' @export
#'
#' @examples
#' library(gsDesign)
#' library(gsDesign2)
#'
#' # Original design
#' x <- gs_design_ahr(info_frac = c(0.5, 0.8, 1))
#'
#' # Updated design
#' xu <- gs_update_ahr(
#'   x = x,
#'   ustime = c(170, x$analysis$event[2:3] )/ max(x$analysis$event),
#'   event_tbl = data.frame(analysis = c(1, 1), event = c(100, 70)))
#'
#' # We assume IA1 p-value of 0.04, one-sided, and future HR is possible from 0.6 to 1.
#' gs_cp_ahr(x = xu,
#'           i = 1,
#'           z_i = -qnorm(0.04),
#'           hr_future = seq(0.6, 1, by = 0.1))
#'
#' # We assume the test statistics z_i is derived by the function hrn2z(), which translates
#' # a HR and number of events into an approximate corresponding Z-value,
#' # using the Schoenfeld approximation.
#' # The future HR is possible from 0.6 to 1.
#' gs_cp_ahr(x = xu,
#'           i = 1,
#'           z_i = -hrn2z(hr = 0.7, n = xu$analysis$event[1], ratio = 1),
#'           hr_future = seq(0.6, 1, by = 0.1))
#'
gs_cp_ahr <- function(x = NULL,
                      i = 1,
                      z_i = 0,
                      hr_future = NULL) {

  # ----------------------------------------- #
  #       initialization                      #
  # ----------------------------------------- #
  n_analysis <- nrow(x$analysis)
  ratio <- x$input$x$input$ratio
  q_e <- ratio / (1 + ratio)
  event_i <- x$analysis$event[i]

  # ----------------------------------------- #
  #       input checking                      #
  # ----------------------------------------- #
  if (is.null(x)) {
    stop("Please provide the design generated by gs_design_ahr, gs_power_ahr or gs_update_ahr.")
  }

  if (length(z_i) > 1) {
    stop("The z_i is required to be a scalers.")
  }

  theta_i <- z_i / sqrt(event_i)

  # mutate hr_future if it is null
  if (is.null(hr_future)) {
    hr_future <- seq(0.5, 1, 0.1)
  }
  theta_future <- -log(hr_future) * sqrt(ratio / (1 + ratio)^2)

  # -------------------------------------------- #
  #   calculate conditional power under H0 theta #
  # -------------------------------------------- #
  ans <- NULL

  for (k in (i+1):n_analysis) {

    ans_k <- NULL
    event_k <- x$analysis$event[k]

    for (j in seq_along(theta_future)) {
      cp <- gs_cp_npe(theta = c(theta_i, theta_future[j]),
                      info = c(event_i, event_k) * q_e * (1 - q_e),
                      a = z_i,
                      b = x$bound$z[x$bound$analysis == k & x$bound$bound == "upper"])

      ans_k_new <- data.frame(current_analysis = i,
                              future_analysis = k,
                              future_hr = hr_future[j],
                              conditional_power = cp)

      ans_k <- rbind(ans_k, ans_k_new)
    }

    ans <- rbind(ans, ans_k)
  }


  # -------------------------------------------- #
  #   output                                     #
  # -------------------------------------------- #
  return(ans)
}
